<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>✨ Word Master ✨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --dark-bg: #0a0e27;
            --dark-card: #151937;
            --dark-hover: #1e2451;
            --dark-text: #e4e4e7;
            --dark-text-secondary: #a1a1aa;
        }

        body {
            font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #2d1b69;
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
            position: relative;
        }


        body.dark-mode {
            background: var(--dark-bg);
            color: #fff;
        }

        /* 다크모드 스타일 개선 */
        .dark-mode .container {
            background: rgba(10, 14, 39, 0.9);
        }

        .dark-mode .header {
            background: rgba(0, 0, 0, 0.5);
        }

        .dark-mode .header::before {
            opacity: 0.3;
        }

        .dark-mode .stats {
            background: rgba(255, 255, 255, 0.05);
        }

        .dark-mode .stat-value {
            background: linear-gradient(45deg, #fff, #ccc);
            -webkit-background-clip: text;          background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .dark-mode .stat-label {
            color: #ddd;
        }

        .dark-mode .tabs {
            background: var(--dark-card);
        }

        .dark-mode .tab {
            color: #888;
        }

        .dark-mode .tab.active {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        .dark-mode .main-content {
            background: var(--dark-card);
        }

        .dark-mode .setting-card {
            background: var(--dark-hover);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* 다크모드 챕터 카드 개선 */
        .dark-mode .chapter-card {
            background: #1a1f3a;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .dark-mode .chapter-card.normal {
            background: linear-gradient(135deg, #1a2f1a 0%, #0f1f0f 100%);
            border-color: #2d5a2d;
        }

        .dark-mode .chapter-card.midterm {
            background: linear-gradient(135deg, #2a2a10 0%, #1f1f0a 100%);
            border-color: #5a5a2d;
        }

        .dark-mode .chapter-card.final {
            background: linear-gradient(135deg, #2a1010 0%, #1f0a0a 100%);
            border-color: #5a2d2d;
        }

        .dark-mode .chapter-card.comprehensive {
            background: linear-gradient(135deg, #1a1a2f 0%, #0f0f1f 100%);
            border-color: #2d2d5a;
        }

        .dark-mode .chapter-card.allwords {
            background: linear-gradient(135deg, #2a2a10 0%, #3a3a10 100%);
            border-color: #5a5a2d;
        }

        .dark-mode .chapter-card:hover {
            background: #252d5a;
            border-color: #666;
        }

        .dark-mode .chapter-title {
            color: var(--dark-text);
        }

        .dark-mode .chapter-info {
            color: var(--dark-text-secondary);
        }

        .dark-mode .progress-info {
            color: var(--dark-text-secondary);
        }

        .dark-mode .progress-bar-container {
            background: rgba(255, 255, 255, 0.1);
        }

        .dark-mode h3 {
            color: var(--dark-text);
        }

        .dark-mode .weak-words-section {
            background: var(--dark-hover);
        }

        .dark-mode .weak-word-item {
            background: #1a1f3a;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .dark-mode .weak-word-title {
            color: var(--dark-text);
        }

        .dark-mode .modal-content {
            background: var(--dark-hover);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .dark-mode .study-mode,
        .dark-mode .test-mode {
            background: var(--dark-bg);
        }

        .dark-mode .word-display {
            background: var(--dark-hover);
            color: #fff;
        }

        .dark-mode .question-card {
            background: var(--dark-hover);
            color: #fff;
        }

        .dark-mode .option-btn {
            background: var(--dark-hover);
            color: #fff;
            border-color: #555;
        }

        .dark-mode .option-btn:hover {
            background: #2a3155;
            border-color: #777;
        }

        
        .container {
            max-width: 500px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            min-height: 100vh;
            position: relative;
            backdrop-filter: blur(20px);
            box-shadow: 0 0 40px rgba(0,0,0,0.3);
        }

        /* 헤더 스타일 - 현대적으로 개선 */
        .header {
            /* 1. 솔리드 폴백 배경 먼저 */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            color: white;
            padding: 30px 20px 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        /* 2. backdrop-filter는 @supports로 감싸기 */
        @supports (backdrop-filter: blur(20px)) or (-webkit-backdrop-filter: blur(20px)) {
            .header {
                background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
            }
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            opacity: 0.9;
            z-index: -1;
        }

        .header h1 {
            font-size: 32px;
            font-weight: 900;
            margin-bottom: 15px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
            position: relative;
            z-index: 1;
            letter-spacing: -0.5px;
            color: #fff;  /* 폴백 추가 */
            animation: shimmer 3s ease-in-out infinite;
        }

        @supports (-webkit-background-clip: text) {
            .header h1 {
                background: linear-gradient(to right, #fff 0%, #f0f0f0 50%, #fff 100%);
                background-size: 200% auto;
                -webkit-background-clip: text;
                background-clip: text;
                -webkit-text-fill-color: transparent;
            }
        }

        @keyframes shimmer {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .header .subtitle {
            font-size: 14px;
            opacity: 0.9;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        /* 단어장 선택기 */
        .vocab-selector {
            margin-top: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .vocab-selector-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .vocab-selector-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .vocab-name {
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* 온라인 카테고리 탭 스타일 - 추가 */
        .online-category-tabs {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 0 16px 20px;
        }

        .online-category-tab {
            width: 100%;
            padding: 16px 24px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 15px;
            position: relative;
            overflow: hidden;
            color: white;
            background: #6b7280;
        }

        /* 각 카테고리별 색상 */
        .online-category-tab[data-category="all"] {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
        }

        .online-category-tab[data-category="toeic"] {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        }

        .online-category-tab[data-category="daily"] {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .online-category-tab[data-category="school"] {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        .online-category-tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }

        .tab-icon {
            font-size: 20px;
        }

        .tab-text {
            font-weight: 600;
            font-size: 15px;
        }
        /* 온라인 단어장 아이템 스타일 */
        .online-vocab-item {
            background: white;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid #e8e8e8;
            position: relative;
            overflow: hidden;
        }

        /* 다운로드 상태 표시 */
        .download-status {
            position: absolute;
            top: 12px;
            right: 12px;
            background: #10b981;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .online-vocab-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.15);
        }

        .online-vocab-header {
            margin-bottom: 16px;
        }

        .online-vocab-info-container {
            flex: 1;
        }

        .online-vocab-title {
            font-size: 18px;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .online-vocab-meta {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .online-vocab-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .online-vocab-badge.intermediate {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        .online-vocab-badge.advanced {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        .online-vocab-description {
            font-size: 14px;
            color: #6b7280;
            line-height: 1.6;
            margin-bottom: 12px;
        }

        .online-vocab-stats {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
        }

        .online-vocab-stat {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #4b5563;
        }

        /* 다운로드 버튼 스타일 */
        .online-download-btn {
            width: 100%;
            padding: 14px 24px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }

        .online-download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }

        .online-download-btn:disabled {
            background: #e5e7eb;
            color: #6b7280;
            cursor: not-allowed;
            transform: none;
        }

        /* 카테고리별 테마 색상 */
        .online-vocab-item[data-category="toeic"] {
            background: linear-gradient(135deg, #ffffff 0%, #eff6ff 100%);
            border-color: #60a5fa;
        }

        .online-vocab-item[data-category="daily"] {
            background: linear-gradient(135deg, #ffffff 0%, #f0fdf4 100%);
            border-color: #86efac;
        }

        .online-vocab-item[data-category="school"] {
            background: linear-gradient(135deg, #ffffff 0%, #fffbeb 100%);
            border-color: #fbbf24;
        }

        /* 빈 상태 스타일 */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 16px;
            color: #6b7280;
        }

        /* 다크모드 스타일 */
        .dark-mode .online-vocab-item {
            background: var(--dark-hover);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .dark-mode .online-vocab-title {
            color: var(--dark-text);
        }

        .dark-mode .online-vocab-description {
            color: var(--dark-text-secondary);
        }

        .dark-mode .online-vocab-stat {
            color: var(--dark-text-secondary);
        }

        .dark-mode .online-download-btn:disabled {
            background: rgba(255, 255, 255, 0.1);
            color: var(--dark-text-secondary);
        }

        /* 카테고리별 다크모드 */
        .dark-mode .online-vocab-item[data-category="toeic"] {
            background: linear-gradient(135deg, var(--dark-hover) 0%, #1e3a8a 100%);
        }

        .dark-mode .online-vocab-item[data-category="daily"] {
            background: linear-gradient(135deg, var(--dark-hover) 0%, #064e3b 100%);
        }

        .dark-mode .online-vocab-item[data-category="school"] {
            background: linear-gradient(135deg, var(--dark-hover) 0%, #78350f 100%);
        }

        /* 로딩 스피너 */
        .spinner {
            width: 40px;
            height: 40px;
            margin: 0 auto 20px;
            border: 4px solid #f3f4f6;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* 단어장 모달 */
        .vocab-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            backdrop-filter: blur(10px);
        }

        .vocab-modal-content {
            background: white;
            border-radius: 20px;
            max-width: 480px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            animation: modalAppear 0.3s ease forwards;
        }

        .dark-mode .vocab-modal-content {
            background: var(--dark-hover);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .vocab-modal-header {
            padding: 24px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            text-align: center;
        }

        .dark-mode .vocab-modal-header {
            border-bottom-color: rgba(255,255,255,0.1);
        }

        .vocab-modal-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 12px;
            color: #1a1a1a;
        }

        .dark-mode .vocab-modal-title {
            color: var(--dark-text);
        }

        .vocab-search {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e8ecff;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .dark-mode .vocab-search {
            background: var(--dark-bg);
            border-color: rgba(255,255,255,0.1);
            color: var(--dark-text);
        }

        .vocab-search:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .vocab-list {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .vocab-item {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .vocab-item button {
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .vocab-item:hover button {
            opacity: 1;
        }
        .dark-mode .vocab-item {
            background: rgba(255,255,255,0.05);
        }
        .dark-mode .vocab-item button {
            color: #a1a1aa;
        }

        .dark-mode .vocab-item button:hover {
            color: #e4e4e7;
        }

        .vocab-item:hover {
            background: #e8ecff;
            transform: translateX(4px);
        }

        .dark-mode .vocab-item:hover {
            background: rgba(102, 126, 234, 0.2);
        }

        .vocab-item.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .vocab-item-info {
            flex: 1;
        }

        .vocab-item-name {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 4px;
        }

        .vocab-item-stats {
            font-size: 13px;
            opacity: 0.8;
        }

        .vocab-item-progress {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .vocab-progress-bar {
            width: 60px;
            height: 6px;
            background: rgba(0,0,0,0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .dark-mode .vocab-progress-bar {
            background: rgba(255,255,255,0.1);
        }

        .vocab-progress-fill {
            height: 100%;
            background: #10b981;
            transition: width 0.3s ease;
        }

        .vocab-item.active .vocab-progress-bar {
            background: rgba(255,255,255,0.3);
        }

        .vocab-item.active .vocab-progress-fill {
            background: white;
        }

        .vocab-streak {
            font-size: 18px;
        }

        .vocab-modal-actions {
            padding: 16px;
            border-top: 1px solid rgba(0,0,0,0.1);
            display: flex;
            gap: 12px;
        }

        .dark-mode .vocab-modal-actions {
            border-top-color: rgba(255,255,255,0.1);
        }

        .vocab-action-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .vocab-action-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .vocab-action-btn.secondary {
            background: #e5e7eb;
            color: #1a1a1a;
        }

        .dark-mode .vocab-action-btn.secondary {
            background: rgba(255,255,255,0.1);
            color: var(--dark-text);
        }

        .vocab-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        /* 통계 카드 - 글래스모피즘 강화 */
        .stats {
            display: flex;
            justify-content: space-around;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            margin-top: 20px;
            position: relative;
            z-index: 1;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }

        .stat-item {
            text-align: center;
            transition: transform 0.3s ease;
        }

        .stat-item:hover {
            transform: translateY(-3px) scale(1.05);
        }

        .stat-value {
            font-size: 28px;
            font-weight: 800;
            display: block;
            background: linear-gradient(45deg, #fff, #f0f0f0);
            -webkit-background-clip: text;          background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }

        .stat-label {
            font-size: 11px;
            opacity: 0.9;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* 탭 네비게이션 - 모던 디자인 */
        .tabs {
            display: flex;
            background: linear-gradient(to bottom, #ffffff, #f8f9fa);
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .tab {
            flex: 1;
            padding: 18px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            position: relative;
            background: transparent;
            border: none;
            color: #666;
            font-size: 15px;
            letter-spacing: 0.5px;
        }

        .tab.active {
            color: #667eea;
            background: rgba(102, 126, 234, 0.08);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 20%;
            right: 20%;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 3px 3px 0 0;
            animation: tabSlideIn 0.3s ease;
        }

        @keyframes tabSlideIn {
            from { transform: scaleX(0); }
            to { transform: scaleX(1); }
        }

        .tab:hover:not(.active) {
            color: #667eea;
            background: rgba(102, 126, 234, 0.04);
        }

        /* 탭 컨텐츠 */
        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* 메인 컨텐츠 */
        .main-content {
            padding: 25px;
            background: #fafbfc;
            min-height: calc(100vh - 200px);
        }

        /* 설정 섹션 */
        .settings-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .setting-card {
            background: #fff;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
            border: 1px solid #e8e8e8;
        }

        .setting-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.12);
            border-color: #667eea;
        }

        .setting-title {
            font-size: 17px;
            font-weight: 700;
            margin-bottom: 16px;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dark-mode .setting-title {
            color: #fff;
        }

        /* 슬라이더 스타일 */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }

        .slider {
            flex: 1;
            height: 6px;
            background: #e0e8ff;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
            appearance: none;
            -webkit-appearance: none;
        }

        .dark-mode .slider {
            background: #2a3155;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
            transition: all 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
        }

        .slider-value {
            min-width: 60px;
            text-align: center;
            font-weight: 600;
            color: #667eea;
        }

        /* 업로드 버튼 개선 */
        .upload-btn {
            width: 100%;
            padding: 20px;
            border: 2px dashed #667eea;
            border-radius: 12px;
            background: linear-gradient(135deg, #f8f9ff 0%, #e8ecff 100%);
            color: #667eea;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            position: relative;
            overflow: hidden;
        }

        .upload-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
            border-color: transparent;
        }

        .dark-mode .upload-btn {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-color: rgba(102, 126, 234, 0.5);
            color: #a5b4fc;
        }

        .dark-mode .upload-btn:hover {
            background: #667eea;
            color: white;
            border-color: transparent;
        }

        /* 음성 설정 개선 */
        .voice-settings {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .voice-select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e8ecff;
            border-radius: 10px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23667eea' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 20px;
            padding-right: 40px;
        }

        .dark-mode .voice-select {
            background-color: var(--dark-bg);
            border-color: #3a3a4e;
            color: #fff;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23fff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
        }

        .voice-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .tts-mode-group {
            display: flex;
            gap: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9ff 0%, #e8ecff 100%);
            border-radius: 10px;
        }

        .dark-mode .tts-mode-group {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 8px;
            margin-top: 8px;
        }

        .dark-mode .checkbox-group {
            background: rgba(102, 126, 234, 0.1);
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #667eea;
            cursor: pointer;
        }

        .checkbox-group label {
            cursor: pointer;
            font-size: 14px;
        }

        .test-voice-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .test-voice-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }

        .visibility-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9ff 0%, #e8ecff 100%);
            border-radius: 10px;
            margin-top: 10px;
        }

        .dark-mode .visibility-controls {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
        }

        /* 챕터 섹션 */
        .chapters-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chapter-grid {
            display: grid;
            gap: 16px;
        }

        /* 챕터 카드 - 현대적 디자인 */
        .chapter-card {
            background: #fff;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            border: 1px solid #e8e8e8;
        }

        .chapter-card.normal {
            background: linear-gradient(135deg, #ffffff 0%, #f0fdf4 100%);
            border-color: #86efac;
        }

        .chapter-card.midterm {
            background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
            border-color: #fbbf24;
        }

        .chapter-card.midterm::before {
            content: '📝';
            position: absolute;
            top: -20px;
            right: -20px;
            font-size: 80px;
            opacity: 0.1;
            transform: rotate(-15deg);
        }

        .chapter-card.final {
            background: linear-gradient(135deg, #fef2f2 0%, #fecaca 100%);
            border-color: #f87171;
        }

        .chapter-card.final::before {
            content: '📋';
            position: absolute;
            top: -20px;
            right: -20px;
            font-size: 80px;
            opacity: 0.1;
            transform: rotate(-15deg);
        }

        .chapter-card.comprehensive {
            background: linear-gradient(135deg, #f3f4ff 0%, #e0e7ff 100%);
            border-color: #a78bfa;
        }

        .chapter-card.comprehensive::before {
            content: '🎯';
            position: absolute;
            top: -20px;
            right: -20px;
            font-size: 80px;
            opacity: 0.1;
            transform: rotate(-15deg);
        }

        .chapter-card.allwords {
            background: linear-gradient(135deg, #fef3c7 0%, #f59e0b 100%);
            border-color: #f59e0b;
            animation: goldPulse 3s ease-in-out infinite;
        }

        @keyframes goldPulse {
            0%, 100% { 
                box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
            }
            50% { 
                box-shadow: 0 8px 24px rgba(245, 158, 11, 0.5);
            }
        }

        .chapter-card.perfect {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
            animation: goldShine 3s linear infinite;
            border-color: #fbbf24;
        }

        @keyframes goldShine {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        .chapter-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.15);
        }

        .chapter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .chapter-title {
            font-size: 18px;
            font-weight: 700;
            color: #1a1a1a;
        }

        .chapter-stars {
            font-size: 22px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }

        /* 무지개 별 스타일 */
        .rainbow-star {
            display: inline-block;
            font-size: 22px;
            background: linear-gradient(45deg, #ff0000, #ff7300, #fffb00, #48ff00, #00ffd5, #002bff, #7a00ff, #ff00c8, #ff0000);
            -webkit-background-clip: text;          background-clip: text;
            -webkit-text-fill-color: transparent;
            background-size: 200% 100%;
            animation: rainbowMove 2s linear infinite;
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.8));
        }

        @keyframes rainbowMove {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        .chapter-progress {
            margin-bottom: 16px;
        }

        .progress-info {
            font-size: 13px;
            color: #666;
            margin-bottom: 8px;
        }

        .progress-bar-container {
            width: 100%;
            height: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 8px;
            position: relative;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 5px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
            position: absolute;
            top: 0;
            left: 0;
        }

        .progress-bar-recent {
            height: 100%;
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
            border-radius: 5px;
            transition: width 0.3s ease;
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0.6;
        }

        .chapter-info {
            color: #666;
            font-size: 13px;
            line-height: 1.6;
        }

        /* 챕터 모달 */
        .chapter-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }

        .chapter-modal-content {
            background: white;
            padding: 32px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            transform: scale(0);
            animation: modalAppear 0.3s ease forwards;
        }

        .dark-mode .chapter-modal-content {
            background: var(--dark-hover);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .chapter-modal-title {
            font-size: 24px;
            margin-bottom: 24px;
            color: #1a1a1a;
            font-weight: 700;
        }

        .dark-mode .chapter-modal-title {
            color: #fff;
        }

        .chapter-modal-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .chapter-modal-btn {
            padding: 16px 24px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 15px;
            position: relative;
            overflow: hidden;
            color: white;
        }

        .chapter-modal-btn.study {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .chapter-modal-btn.test {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        .chapter-modal-btn.close {
            background: #6b7280;
            margin-top: 8px;
        }

        .chapter-modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }

        /* 빠른 액션 버튼들 */
        .quick-actions {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .quick-action-btn {
            padding: 20px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
            position: relative;
            overflow: hidden;
            text-align: center;
            min-height: 100px;
        }

        .quick-action-btn .icon {
            font-size: 28px;
            margin-bottom: 4px;
        }

        .quick-action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.2);
        }

        .focus-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            grid-column: 1 / -1;
        }

        .save-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .load-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        }

        /* 리셋 버튼 */
        .reset-section {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 1px solid #e5e7eb;
        }

        .dark-mode .reset-section {
            border-top-color: rgba(255,255,255,0.1);
        }

        .reset-btn {
            width: 100%;
            padding: 14px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 15px;
        }

        .reset-btn:hover {
            background: #dc2626;
            transform: scale(1.02);
            box-shadow: 0 8px 20px rgba(239, 68, 68, 0.3);
        }

        /* 약한단어 섹션 */
        .weak-words-section {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 20px;
        }

        .weak-words-list {
            display: none;
            max-height: 400px;
            overflow-y: auto;
            padding: 8px;
        }

        .weak-word-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
            transition: all 0.3s ease;
            border: 1px solid #fecaca;
        }

        .weak-word-item:hover {
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.1);
            border-color: #f87171;
        }

        .weak-word-info {
            flex: 1;
        }

        .weak-word-title {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 4px;
            color: #1a1a1a;
        }

        .weak-word-stats {
            font-size: 12px;
            color: #666;
        }

        .weak-word-score {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            min-width: 45px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
        }

        /* 학습 모드 */
        .study-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: none;
            flex-direction: column;
            z-index: 1000;
        }

        .study-header {
            padding: 20px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(20px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .study-controls {
            display: flex;
            gap: 8px;
        }

        .study-control-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-weight: 500;
        }

        .study-control-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }

        .progress-bar {
            height: 4px;
            background: rgba(255,255,255,0.2);
            position: relative;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #fff, rgba(255,255,255,0.8));
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        .study-card {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
            text-align: center;
        }

        .word-display {
            background: white;
            border-radius: 24px;
            padding: 48px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            min-width: 80%;
            max-width: 600px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .word-display:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 30px 80px rgba(0,0,0,0.3);
        }

        .word-text {
            font-size: 48px;
            font-weight: 800;
            color: #1a1a1a;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
            transition: opacity 0.3s ease;
        }

        .dark-mode .word-text {
            color: #fff;
        }

        .word-pronunciation {
            font-size: 24px;
            color: #9ca3af;
            margin-bottom: 24px;
            transition: opacity 0.3s ease;
        }

        .dark-mode .word-pronunciation {
            color: #6b7280;
        }

        .word-meaning {
            font-size: 28px;
            color: #4b5563;
            margin-bottom: 20px;
            font-weight: 600;
            transition: opacity 0.3s ease;
        }

        .dark-mode .word-meaning {
            color: #d1d5db;
        }

        .word-example {
            font-size: 20px;
            color: #6b7280;
            font-style: italic;
            line-height: 1.6;
            margin-bottom: 8px;
            transition: opacity 0.3s ease;
        }

        .dark-mode .word-example {
            color: #9ca3af;
        }

        .word-example-meaning {
            font-size: 18px;
            color: #9ca3af;
            line-height: 1.6;
            transition: opacity 0.3s ease;
        }

        .dark-mode .word-example-meaning {
            color: #6b7280;
        }

        .word-element.hidden {
            opacity: 0.1;
        }

        .pause-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 24px 48px;
            border-radius: 16px;
            font-size: 24px;
            font-weight: 600;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            opacity: 0;
            animation: pauseFadeInOut 1s ease-out;
        }

        @keyframes pauseFadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        /* 테스트 모드 */
        .test-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            display: none;
            flex-direction: column;
            z-index: 1000;
        }

        .test-header {
            padding: 20px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(20px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .test-controls {
            display: flex;
            gap: 8px;
        }

        .test-stats {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .test-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 4px 16px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .test-stat-value {
            font-size: 18px;
            font-weight: 700;
        }

        .test-stat-label {
            font-size: 11px;
            opacity: 0.9;
        }

        .timer-bar {
            height: 8px;
            background: rgba(255,255,255,0.2);
            overflow: hidden;
            position: relative;
        }

        .timer-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #dc2626);
            transition: width 0.1s linear;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }

        .test-card {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .question-card {
            background: white;
            border-radius: 20px;
            padding: 32px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            margin-bottom: 20px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            min-height: 280px; /* 최소 높이 설정 */
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .question-card.correct {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
        }

        .dark-mode .question-card.correct {
            background: linear-gradient(135deg, #064e3b 0%, #065f46 100%);
        }

        .question-card.incorrect {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
        }

        .dark-mode .question-card.incorrect {
            background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
        }

        .question-word {
            font-size: 40px;
            font-weight: 800;
            color: #1a1a1a;
            margin-bottom: 24px;
            letter-spacing: -0.5px;
        }

        .dark-mode .question-word {
            color: #fff;
        }

        .question-example {
            font-size: 18px;
            color: #4b5563;
            font-style: italic;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(0,0,0,0.1);
            line-height: 1.6;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .question-example.show {
            opacity: 1;
        }

        .question-example-meaning {
            font-size: 16px;
            color: #6b7280;
            margin-top: 8px;
            line-height: 1.6;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .question-example-meaning.show {
            opacity: 1;
        }
        .dark-mode .question-example {
            color: #d1d5db;
            border-top-color: rgba(255,255,255,0.1);
        }

        .question-example-meaning {
            font-size: 16px;
            color: #6b7280;
            margin-top: 8px;
            line-height: 1.6;
        }

        .dark-mode .question-example-meaning {
            color: #9ca3af;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }

        .option-btn {
            padding: 18px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            background: white;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .option-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            border-color: #667eea;
        }

        .option-btn.correct {
            background: #10b981;
            color: white;
            border-color: #10b981;
            animation: correctPulse 0.5s ease;
        }

        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .option-btn.incorrect {
            background: #ef4444;
            color: white;
            border-color: #ef4444;
            animation: shake 0.5s ease;
        }

        .dont-know-btn {
            width: 100%;
            padding: 18px;
            background: #6b7280;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .dont-know-btn:hover {
            background: #4b5563;
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(107, 114, 128, 0.3);
        }

        /* 파티클 효과 */
        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ffd700;  /* 금색 기본값 */
            border-radius: 50%;
            pointer-events: none;
            animation: particleAnimation 1s ease-out forwards; 
            z-index: 9999;
        }

        @keyframes particleAnimation {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        /* 100점 효과 */
        .perfect-star-animation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 180px;
            z-index: 3000;
            opacity: 0;
            animation: perfectStarBurst 3s ease-out;
            filter: drop-shadow(0 0 40px gold);
            display: flex;
            gap: 10px;
        }

        .perfect-star-animation .rainbow-star {
            font-size: 180px;
            filter: drop-shadow(0 0 20px gold);
        }

        @keyframes perfectStarBurst {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0) rotate(0deg); 
            }
            50% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.2) rotate(180deg); 
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(1) rotate(360deg); 
            }
        }

        .firework {
            position: absolute;
            width: 4px;
            height: 4px;
            background: gold;
            border-radius: 50%;
            animation: fireworkExplode 2s ease-out forwards;
        }

        @keyframes fireworkExplode {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--fx), var(--fy)) scale(0);
                opacity: 0;
            }
        }

        /* 모달 */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            background: white;
            padding: 32px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            transform: scale(0);
            animation: modalAppear 0.3s ease forwards;
        }

        @keyframes modalAppear {
            to { transform: scale(1); }
        }

        .modal-content h3 {
            font-size: 24px;
            margin-bottom: 16px;
            color: #1a1a1a;
            font-weight: 700;
        }

        .dark-mode .modal-content h3 {
            color: #fff;
        }

        .modal-content p {
            font-size: 16px;
            margin-bottom: 24px;
            color: #4b5563;
            line-height: 1.6;
        }

        .dark-mode .modal-content p {
            color: #d1d5db;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .modal-btn {
            flex: 1;
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 15px;
        }

        .modal-btn.yes {
            background: #10b981;
            color: white;
        }

        .modal-btn.no {
            background: #ef4444;
            color: white;
        }

        .modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }

        /* 챕터 설정 모달 */
        .chapter-setting-input {
            width: 100%;
            padding: 14px;
            border: 2px solid #667eea;
            border-radius: 10px;
            font-size: 20px;
            text-align: center;
            margin: 20px 0;
            transition: all 0.3s ease;
        }

        .chapter-setting-input:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
            transform: scale(1.02);
        }

        .chapter-setting-hint {
            font-size: 13px;
            color: #6b7280;
            margin-top: 8px;
        }

        /* 단어장 이름 설정 모달 */
        .vocab-name-input {
            width: 100%;
            padding: 14px;
            border: 2px solid #667eea;
            border-radius: 10px;
            font-size: 18px;
            margin: 20px 0;
            transition: all 0.3s ease;
        }

        .dark-mode .vocab-name-input {
            background: var(--dark-bg);
            border-color: rgba(102, 126, 234, 0.5);
            color: var(--dark-text);
        }

        .vocab-name-input:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        /* 피드백 */
        .feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            padding: 24px 48px;
            border-radius: 16px;
            font-size: 20px;
            font-weight: 600;
            text-align: center;
            z-index: 3000;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            display: none;
        }

        .feedback.show {
            display: block;
            animation: feedbackShow 0.5s ease forwards;
        }

        @keyframes feedbackShow {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); }
            50% { transform: translate(-50%, -50%) scale(1.1) rotate(90deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
        }

        .feedback.success {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .feedback.error {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .feedback.warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            font-size: 18px;
            padding: 20px 40px;
        }


        /* 별 날아오는 애니메이션 */
        .flying-star {
            position: fixed;
            font-size: 102px;
            z-index: 3000;
            filter: drop-shadow(0 0 20px gold) drop-shadow(0 0 40px gold);
            pointer-events: none;
        }
        
        /* 무지개별도 동일한 크기로 */
        .flying-star .rainbow-star {
            font-size: 102px;
        }

        /* 3개 별 - 삼각형 배치 */
        .triangle-top {
            animation: flyFromTop 1.2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .triangle-left {
            animation: flyFromLeft 1.2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .triangle-right {
            animation: flyFromRight 1.2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        /* 2개 별 - 나란히 배치 */
        .line-left {
            animation: flyFromLeftSide 1.2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .line-right {
            animation: flyFromRightSide 1.2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        /* 1개 별 - 중앙 */
        .single-star {
            animation: flyFromRandom 1.2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        /* 삼각형 배치 애니메이션 */
        @keyframes flyFromTop {
            0% {
                transform: translate(-50%, -50%) translateY(-1000px) rotate(0deg) scale(0.1);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) translateY(-70px) rotate(720deg) scale(1);
                opacity: 1;
            }
        }

        @keyframes flyFromLeft {
            0% {
                transform: translate(-50%, -50%) translate(-1000px, 1000px) rotate(0deg) scale(0.1);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) translate(-70px, 70px) rotate(720deg) scale(1);
                opacity: 1;
            }
        }

        @keyframes flyFromRight {
            0% {
                transform: translate(-50%, -50%) translate(1000px, 1000px) rotate(0deg) scale(0.1);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) translate(70px, 70px) rotate(720deg) scale(1);
                opacity: 1;
            }
        }

        /* 나란히 배치 애니메이션 */
        @keyframes flyFromLeftSide {
            0% {
                transform: translate(-50%, -50%) translateX(-1200px) rotate(0deg) scale(0.1);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) translateX(-60px) rotate(720deg) scale(1);
                opacity: 1;
            }
        }

        @keyframes flyFromRightSide {
            0% {
                transform: translate(-50%, -50%) translateX(1200px) rotate(0deg) scale(0.1);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) translateX(60px) rotate(720deg) scale(1);
                opacity: 1;
            }
        }

        /* 단일 별 애니메이션 */
        @keyframes flyFromRandom {
            0% {
                transform: translate(-50%, -50%) translate(-800px, -800px) rotate(0deg) scale(0.1);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) translate(0, 0) rotate(1080deg) scale(1);
                opacity: 1;
            }
        }

        /* 충격파 효과 */
        .shockwave {
            position: fixed;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 3px solid rgba(255, 215, 0, 0.8);
            z-index: 2998;
            pointer-events: none;
            animation: shockwaveExpand 0.8s ease-out forwards;
        }

        @keyframes shockwaveExpand {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(4);
                opacity: 0;
            }
        }

        /* 화면 흔들림 효과 */
        @keyframes screenShake {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-2.5px, -2.5px); }
            20% { transform: translate(2.5px, -2.5px); }
            30% { transform: translate(-2.5px, 2.5px); }
            40% { transform: translate(2.5px, 2.5px); }
            50% { transform: translate(-1.5px, -1.5px); }
            60% { transform: translate(1.5px, -1.5px); }
            70% { transform: translate(-1.5px, 1.5px); }
            80% { transform: translate(1.5px, 1.5px); }
            90% { transform: translate(-0.5px, -0.5px); }
        }


        @keyframes sparkle {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--x), var(--y)) scale(0);
                opacity: 0;
            }
        }

        /* 다크모드 토글 */
        .dark-mode-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.8) 100%);
            backdrop-filter: blur(10px);
            color: #1a1a1a;
            border: 1px solid rgba(0,0,0,0.1);
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            font-size: 24px;
            transition: all 0.3s ease;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dark-mode .dark-mode-toggle {
            background: linear-gradient(135deg, rgba(30,30,30,0.9) 0%, rgba(20,20,20,0.8) 100%);
            color: #fbbf24;
            border-color: rgba(255,255,255,0.1);
        }

        .dark-mode-toggle:hover {
            transform: scale(1.1) rotate(180deg);
            box-shadow: 0 8px 30px rgba(0,0,0,0.25);
        }

        /* 스크롤바 스타일링 */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }

        .dark-mode ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
        }

        .dark-mode ::-webkit-scrollbar-thumb {
            background: #764ba2;
        }

        /* 숨김 클래스 */
        .hidden {
            display: none !important;
        }

        /* 파일 입력 숨김 */
        #fileInput, #backupInput {
            display: none;
        }

        /* 반응형 디자인 */
        @media (max-width: 768px) {
            .container {
                max-width: 100%;
                box-shadow: none;
            }

            .header h1 {
                font-size: 28px;
            }

            .stat-value {
                font-size: 24px;
            }

            .stat-label {
                font-size: 10px;
            }

            .tab {
                font-size: 13px;
                padding: 12px;
            }

            .main-content {
                padding: 16px;
                min-height: calc(100vh - 180px);
            }

            .setting-title {
                font-size: 15px;
            }

            .upload-btn {
                font-size: 15px;
                padding: 16px;
            }

            .chapter-card {
                padding: 16px;
            }

            .chapter-title {
                font-size: 15px;
            }

            .chapter-stars {
                font-size: 18px;
            }

            .rainbow-star {
                font-size: 18px;
            }

            .chapter-info {
                font-size: 12px;
            }

            .word-display {
                padding: 32px;
                min-width: 85%;
            }

            .word-text {
                font-size: 28px;
            }

            .word-pronunciation {
                font-size: 16px;
            }

            .word-meaning {
                font-size: 20px;
            }

            .word-example {
                font-size: 16px;
            }

            .word-example-meaning {
                font-size: 14px;
            }

            .question-card {
                padding: 24px;
            }

            .question-word {
                font-size: 26px;
            }

            .question-example {
                font-size: 15px;
            }

            .options-grid {
                gap: 8px;
            }

            .option-btn {
                font-size: 13px;
                padding: 14px 6px;
            }

            .dont-know-btn {
                font-size: 15px;
                padding: 16px;
            }

            .modal-content {
                padding: 24px;
            }

            .modal-content h3 {
                font-size: 20px;
            }

            .modal-content p {
                font-size: 14px;
            }

            .perfect-star-animation {
                font-size: 100px;
            }

            .perfect-star-animation .rainbow-star {
                font-size: 100px;
            }

            .dark-mode-toggle {
                width: 48px;
                height: 48px;
                font-size: 20px;
                bottom: 16px;
                right: 16px;
            }

            .vocab-modal-content {
                max-width: 100%;
                border-radius: 20px 20px 0 0;
                max-height: 90vh;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 24px;
            }

            .header .subtitle {
                font-size: 12px;
            }

            .stats {
                padding: 12px;
            }

            .stat-value {
                font-size: 20px;
            }

            .stat-label {
                font-size: 9px;
            }

            .tabs {
                margin-top: 0;
            }

            .tab {
                font-size: 12px;
                padding: 10px;
            }

            .quick-actions {
                grid-template-columns: 1fr;
            }

            .test-stats {
                gap: 12px;
            }

            .test-stat {
                padding: 4px 12px;
            }

            .test-stat-value {
                font-size: 16px;
            }

            .test-stat-label {
                font-size: 10px;
            }

            .vocab-selector-btn {
                font-size: 12px;
                padding: 6px 16px;
            }

            .vocab-name {
                max-width: 100px;
            }
        }
    
    </style>
</head>
<body>

    <div class="container">
        <div class="header">
            <h1>✨ Word Master ✨</h1>
            <div class="subtitle">Master Your Vocabulary</div>
            
            <!-- 단어장 선택기 -->
            <div class="vocab-selector">
                <button class="vocab-selector-btn" onclick="showVocabModal()">
                    <span>📚</span>
                    <span class="vocab-name" id="currentVocabName">단어장 선택</span>
                    <span>▼</span>
                </button>
            </div>
            
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-value" id="totalWords">0</span>
                    <span class="stat-label">총 단어</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="weakWords">0</span>
                    <span class="stat-label">약한 단어</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="accuracy">0%</span>
                    <span class="stat-label">전체 정답률</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="userStars">⭐ 1000</span>
                    <span class="stat-label">보유 별</span>
                </div>
            </div>
        </div>

        <!-- 탭 네비게이션 -->
        <div class="tabs">
            <button class="tab active" onclick="switchTab('chapters')">📚 챕터</button>
            <button class="tab" onclick="switchTab('weakwords')">📋 약한단어</button>
            <button class="tab" onclick="switchTab('settings')">⚙️ 설정</button>
        </div>

        <div class="main-content">
            <!-- 챕터 탭 -->
            <div class="tab-content active" id="chapters-tab">
                <div class="chapters-container">
                    <h3 style="margin: 20px 0; color: #1a1a1a; font-size: 20px; font-weight: 700;">📚 챕터 목록</h3>
                    <div class="chapter-grid" id="chapterList">
                        <div style="text-align: center; color: #6b7280; padding: 60px;">
                            단어장을 선택하거나 새로 만들어주세요
                        </div>
                    </div>
                </div>
            </div>

            <!-- 약한단어 탭 -->
            <div class="tab-content" id="weakwords-tab">
                <div class="weak-words-section">
                    <!-- 빠른 액션 버튼들 -->
                    <div class="quick-actions">
                        <button class="quick-action-btn focus-btn" onclick="showFocusModal()">
                            <div class="icon">🎯</div>
                            <div>집중학습</div>
                            <div style="font-size: 12px; opacity: 0.8;">약한단어 특화</div>
                        </button>
                    </div>
                    
                    <h3 style="margin: 20px 0; color: #1a1a1a; font-size: 20px; font-weight: 700;">📋 약한단어 목록 (상위 20개)</h3>
                    <div class="weak-words-list" id="weakWordsList" style="display: block; max-height: none;">
                        <div style="text-align: center; color: #6b7280; padding: 40px;">
                            약한 단어가 없습니다
                        </div>
                    </div>
                </div>
            </div>

            <!-- 설정 탭 -->
            <div class="tab-content" id="settings-tab">
                <div class="settings-section">
                    <!-- 온라인 단어장 다운로드 -->
                    <div class="setting-card">
                        <div class="setting-title">
                            🌐 온라인 단어장 다운로드
                        </div>
                        <button class="upload-btn" onclick="showOnlineVocabStore()">
                            <span style="font-size: 24px;">📥</span>
                            <span>단어장 스토어 열기</span>
                        </button>
                        <div style="margin-top: 10px; font-size: 14px; color: #6b7280;">
                            다양한 단어장을 무료로 다운로드하세요
                        </div>
                    </div>

                    <!-- 로컬 파일 업로드 (기존 기능 유지) -->
                    <div class="setting-card">
                        <div class="setting-title">
                            📁 로컬 파일 업로드
                        </div>
                        <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                            <span style="font-size: 24px;">📤</span>
                            <span>파일 선택</span>
                        </button>
                        <input type="file" id="fileInput" accept=".txt" multiple>
                        <div style="margin-top: 10px; font-size: 14px; color: #6b7280;">
                            지원 형식: .txt 파일
                        </div>
                    </div>

                    <!-- TTS 설정 -->
                    <div class="setting-card">
                        <div class="setting-title">
                            🔊 음성 설정 (TTS)
                        </div>
                        <div class="voice-settings">
                            <select class="voice-select" id="voiceSelect" onchange="changeVoice()">
                                <option value="">음성 자동 선택</option>
                            </select>
                            <div class="tts-mode-group">
                                <div class="checkbox-group">
                                    <input type="checkbox" id="wordMode" checked>
                                    <label for="wordMode">단어 읽기</label>
                                </div>
                                <div class="checkbox-group">
                                    <input type="checkbox" id="exampleMode">
                                    <label for="exampleMode">예문 읽기</label>
                                </div>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="testWordTTS" checked>
                                <label for="testWordTTS">테스트모드에서 단어 읽기</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="testAnswerTTS">
                                <label for="testAnswerTTS">테스트모드에서 예문 읽기</label>
                            </div>
                            <button class="test-voice-btn" onclick="testVoice()">🎤 음성 테스트</button>
                        </div>
                    </div>

                    <!-- 학습 속도 설정 -->
                    <div class="setting-card">
                        <div class="setting-title">
                            ⏱️ 학습 속도 설정
                        </div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="studySpeedSlider" 
                                min="10" max="100" value="28" step="1"
                                onchange="updateStudySpeed()">
                            <span class="slider-value" id="studySpeedValue">2.8초</span>
                        </div>
                        <div style="margin-top: 10px; font-size: 14px; color: #6b7280;">
                            학습 모드에서 다음 카드로 넘어가는 시간
                        </div>
                    </div>

                    <!-- TTS 프리로드 설정 -->
                    <div class="setting-card">
                        <div class="setting-title">
                            🚀 TTS 프리로드 설정
                        </div>
                        <div class="slider-container">
                            <input type="range" class="slider" id="ttsPreloadSlider" 
                                min="0" max="10" value="0" step="1"
                                onchange="updateTTSPreload()">
                            <span class="slider-value" id="ttsPreloadValue">0.0초</span>
                        </div>
                        <div style="margin-top: 10px; font-size: 14px; color: #6b7280;">
                            다음 카드 TTS를 미리 실행하여 딜레이를 줄입니다
                        </div>
                    </div>

                    <!-- 학습 모드 가시성 설정 -->
                    <div class="setting-card">
                        <div class="setting-title">
                            👁️ 학습 모드 가시성 설정
                        </div>
                        <div class="visibility-controls">
                            <div class="checkbox-group">
                                <input type="checkbox" id="showWord" checked>
                                <label for="showWord">단어 보이기</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="showPronunciation" checked>
                                <label for="showPronunciation">발음 보이기</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="showMeaning" checked>
                                <label for="showMeaning">뜻 보이기</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="showExample" checked>
                                <label for="showExample">예문 보이기</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="showExampleMeaning" checked>
                                <label for="showExampleMeaning">예문 뜻 보이기</label>
                            </div>
                        </div>
                    </div>

                    <!-- 데이터 관리 -->
                    <div class="setting-card">
                        <div class="setting-title">
                            💾 데이터 관리
                        </div>
                        <div class="quick-actions">
                            <button class="quick-action-btn save-btn" onclick="saveData()">
                                <div class="icon">💾</div>
                                <div>데이터 저장</div>
                                <div style="font-size: 12px; opacity: 0.8;">JSON 다운로드</div>
                            </button>
                            <button class="quick-action-btn load-btn" onclick="loadBackupData()">
                                <div class="icon">📂</div>
                                <div>백업 불러오기</div>
                                <div style="font-size: 12px; opacity: 0.8;">JSON 업로드</div>
                            </button>
                        </div>
                    </div>
                    <!-- 구매 기록 -->
                    <div class="setting-card">
                        <div class="setting-title">
                            🛒 구매 기록
                        </div>
                        <div style="font-size: 14px; color: #6b7280;">
                            총 구매한 단어장: <span id="purchaseCount">0</span>개
                        </div>
                    </div>
                    <!-- 초기화 -->
                    <div class="reset-section">
                        <button class="reset-btn" onclick="showResetModal()">
                            🗑️ 현재 단어장 초기화
                        </button>
                    </div>
                    <!-- 완전 초기화 (추가) -->
                    <div class="setting-card" style="margin-top: 30px; border: 2px solid #ef4444;">
                        <div class="setting-title" style="color: #ef4444;">
                            ⚠️ 완전 초기화 (위험!)
                        </div>
                        <div style="font-size: 14px; color: #ef4444; margin-bottom: 15px;">
                            모든 단어장, 학습 기록, 보유 별이 삭제되며 복구할 수 없습니다.
                        </div>
                        <button class="reset-btn" style="background: #dc2626;" onclick="showCompleteResetModal()">
                            💀 어플 완전 초기화
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 학습 모드 -->
    <div class="study-mode" id="studyMode">
        <div class="study-header">
            <div class="study-controls">
                <button class="study-control-btn" onclick="toggleFullscreen()">⛶</button>
                <button class="study-control-btn" onclick="exitStudyMode()">✕</button>
            </div>
            <div style="color: white; font-weight: 600; font-size: 18px;">📚 학습 모드</div>
            <div></div>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="studyProgress"></div>
        </div>
        <div class="study-card">
            <div class="word-display" id="wordDisplay" onclick="toggleStudyPause()">
                <div class="word-text word-element" id="studyWordText">단어</div>
                <div class="word-pronunciation word-element" id="studyWordPronunciation"></div>
                <div class="word-meaning word-element" id="studyWordMeaning">뜻</div>
                <div class="word-example word-element" id="studyWordExample">예문</div>
                <div class="word-example-meaning word-element" id="studyWordExampleMeaning">예문 뜻</div>
            </div>
        </div>
        <div class="pause-indicator hidden" id="pauseIndicator">일시정지</div>
    </div>

    <!-- 테스트 모드 -->
    <div class="test-mode" id="testMode">
        <div class="test-header">
            <div class="test-controls">
                <button class="study-control-btn" onclick="toggleFullscreen()">⛶</button>
                <button class="study-control-btn" onclick="toggleTestPause()">||</button>
                <button class="study-control-btn" onclick="exitTestMode()">✕</button>
            </div>
            <div style="font-weight: 600; font-size: 18px;">TEST</div>
            <div class="test-stats">
                <div class="test-stat">
                    <span class="test-stat-value" id="testProgress">0/0</span>
                    <span class="test-stat-label">진행률</span>
                </div>
                <div class="test-stat">
                    <span class="test-stat-value" id="currentAccuracy">0%</span>
                    <span class="test-stat-label">정답률</span>
                </div>
            </div>
        </div>
        <div class="timer-bar">
            <div class="timer-fill" id="timerFill"></div>
        </div>
        <div class="test-card">
            <div class="question-card" id="questionCard">
                <div class="question-word" id="questionWord">단어</div>
                <div class="question-example" id="questionExample">예문</div>
                <div class="question-example-meaning" id="questionExampleMeaning">예문 뜻</div>
            </div>
            <div class="options-grid" id="optionsGrid">
                <!-- 선택지들이 여기에 생성됩니다 -->
            </div>
            <button class="dont-know-btn" onclick="selectDontKnow()">🤔 모르겠어요</button>
        </div>
    </div>

    <!-- 단어장 선택 모달 -->
    <div class="vocab-modal" id="vocabModal">
        <div class="vocab-modal-content">
            <div class="vocab-modal-header">
                <h3 class="vocab-modal-title">📚 단어장 선택</h3>
                <input type="text" class="vocab-search" placeholder="🔍 검색..." onkeyup="filterVocabs(this.value)">
            </div>
            <div class="vocab-list" id="vocabList">
                <!-- 단어장 목록이 여기에 표시됩니다 -->
            </div>
            <div class="vocab-modal-actions">
                <button class="vocab-action-btn primary" onclick="createNewVocab()">
                    <span>➕</span>
                    <span>새 단어장 만들기</span>
                </button>
                <button class="vocab-action-btn secondary" onclick="closeVocabModal()">
                    닫기
                </button>
            </div>
        </div>
    </div>

    <!-- 챕터 모달 -->
    <div class="chapter-modal" id="chapterModal">
        <div class="chapter-modal-content">
            <h3 class="chapter-modal-title" id="chapterModalTitle">챕터 1</h3>
            <div class="chapter-modal-actions">
                <button class="chapter-modal-btn study" onclick="startStudyFromModal()">
                    📚 학습
                </button>
                <button class="chapter-modal-btn test" onclick="startTestFromModal()">
                    📝 테스트
                </button>
                <button class="chapter-modal-btn close" onclick="closeChapterModal()">
                    닫기
                </button>
            </div>
        </div>
    </div>

    <!-- 모달들 -->
    <div class="modal" id="chapterSettingModal">
        <div class="modal-content">
            <h3>📚 챕터 설정</h3>
            <p>챕터당 누적할 단어 개수를 설정해주세요</p>
            <input type="number" class="chapter-setting-input" id="chapterSizeInput" 
                   min="10" max="200" value="10" placeholder="10">
            <div class="chapter-setting-hint">최소 10개 ~ 최대 200개</div>
            <div class="modal-buttons">
                <button class="modal-btn yes" onclick="confirmChapterSetting()">확인</button>
            </div>
        </div>
    </div>

    <div class="modal" id="vocabNameModal">
        <div class="modal-content">
            <h3>📚 새 단어장 만들기</h3>
            <p>단어장 이름을 입력해주세요</p>
            <input type="text" class="vocab-name-input" id="vocabNameInput" 
                   placeholder="예: TOEIC 기초" maxlength="30">
            <div class="modal-buttons">
                <button class="modal-btn yes" onclick="confirmVocabName()">확인</button>
                <button class="modal-btn no" onclick="closeVocabNameModal()">취소</button>
            </div>
        </div>
    </div>

    <div class="modal" id="focusModal">
        <div class="modal-content">
            <h3>🎯 집중학습 모드</h3>
            <p>약한 단어들로만 구성된 학습을 시작하시겠습니까?</p>
            <div class="modal-buttons">
                <button class="modal-btn yes" onclick="startFocusStudy()">학습</button>
                <button class="modal-btn no" onclick="startFocusTest()">테스트</button>
            </div>
            <button class="modal-btn" onclick="closeFocusModal()" style="margin-top: 10px; background: #6b7280; color: white;">취소</button>
        </div>
    </div>

    <div class="modal" id="resetModal">
        <div class="modal-content">
            <h3>🗑️ 데이터 초기화</h3>
            <p>현재 단어장의 모든 학습 데이터를 초기화하시겠습니까?</p>
            <p style="color: #ef4444; font-size: 14px;">이 작업은 되돌릴 수 없습니다</p>
            <p style="color: #ef4444; font-size: 14px;">단, 구매한 단어장은 재구매 무료</p>
            <div class="modal-buttons">
                <button class="modal-btn yes" onclick="resetData()">예</button>
                <button class="modal-btn no" onclick="closeResetModal()">아니오</button>
            </div>
        </div>
    </div>
    <div class="modal" id="completeResetModal1">
        <div class="modal-content">
            <h3 style="color: #ef4444;">⚠️ 경고: 완전 초기화</h3>
            <p style="color: #ef4444; font-weight: 600;">정말로 모든 데이터를 삭제하시겠습니까?</p>
            <p>다음 항목들이 <strong>영구적으로</strong> 삭제됩니다:</p>
            <ul style="text-align: left; margin: 20px 0; color: #4b5563;">
                <li>✓ 모든 단어장과 단어들</li>
                <li>✓ 모든 학습 기록과 통계</li>
                <li>✓ 보유 중인 별 <span id="resetStarCount" style="color: #f59e0b; font-weight: 600;"></span>개</li>
                <li>✓ 구매한 단어장 기록 (재구매 필요)</li>
            </ul>
            <p style="color: #ef4444; font-size: 14px;">이 작업은 되돌릴 수 없습니다!</p>
            <div class="modal-buttons">
                <button class="modal-btn yes" style="background: #ef4444;" onclick="showCompleteResetModal2()">계속</button>
                <button class="modal-btn no" style="background: #6b7280;" onclick="closeCompleteResetModal1()">취소</button>
            </div>
        </div>
    </div>

    <div class="modal" id="completeResetModal2">
        <div class="modal-content">
            <h3 style="color: #dc2626;">💀 최종 확인</h3>
            <p style="color: #dc2626; font-weight: 700; font-size: 18px;">정말 확실하십니까?</p>
            <p>지금 취소하지 않으면 <strong style="color: #dc2626;">모든 것이 사라집니다.</strong></p>
            <div style="background: #fee2e2; padding: 15px; border-radius: 10px; margin: 20px 0;">
                <p style="color: #991b1b; margin: 0;">
                    마지막 기회입니다. 정말로 처음부터 다시 시작하시겠습니까?
                </p>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn yes" style="background: #dc2626;" onclick="completeReset()">
                    완전 초기화 실행
                </button>
                <button class="modal-btn no" style="background: #10b981;" onclick="closeCompleteResetModal2()">
                    취소 (안전)
                </button>
            </div>
        </div>
    </div>

    <div class="modal" id="weakWordsRecommendModal">
        <div class="modal-content">
            <h3>💡 약한단어 집중학습 권장</h3>
            <p>약한 단어가 10개 이상 누적되었습니다.<br>집중학습을 진행하시겠습니까?</p>
            <div class="modal-buttons">
                <button class="modal-btn yes" onclick="acceptWeakWordsRecommend()">예</button>
                <button class="modal-btn no" onclick="rejectWeakWordsRecommend()">아니오</button>
            </div>
        </div>
    </div>

    <!-- 온라인 단어장 스토어 모달 -->
    <div class="vocab-modal" id="onlineVocabStoreModal">
        <div class="vocab-modal-content">
            <div class="vocab-modal-header">
                <h3 class="vocab-modal-title">🌐 온라인 단어장 스토어</h3>
                <input type="text" class="vocab-search" id="onlineVocabSearch" placeholder="🔍 단어장 검색..." onkeyup="searchOnlineVocabs(this.value)">
            </div>
            
            <!-- 카테고리 탭 -->
            <div style="display: flex; gap: 8px; margin: 16px 0; flex-wrap: wrap;">
                <button class="category-tab active" onclick="filterByCategory('all')">전체</button>
                <button class="category-tab" onclick="filterByCategory('toeic')">TOEIC</button>
                <button class="category-tab" onclick="filterByCategory('school')">학교</button>
                <button class="category-tab" onclick="filterByCategory('hobby')">취미</button>
                <button class="category-tab" onclick="filterByCategory('basic')">기초</button>
            </div>
            
            <!-- 단어장 목록 -->
            <div class="vocab-list" id="onlineVocabList">
                <div style="text-align: center; padding: 60px;">
                    <div class="loading-spinner">
                        <div class="spinner-circle"></div>
                    </div>
                    <p style="margin-top: 20px; color: #6b7280;">단어장 목록을 불러오는 중...</p>
                </div>
            </div>
            
            <div class="vocab-modal-actions">
                <button class="vocab-action-btn secondary" onclick="closeOnlineVocabStore()">
                    닫기
                </button>
            </div>
            <div class="modal" id="vocabMergeModal">
                <div class="modal-content">
                    <h3>📚 단어장 다운로드</h3>
                    <p id="vocabMergeMessage">다운로드한 단어를 현재 단어장에 합치시겠습니까?</p>
                    <p style="font-size: 14px; color: #6b7280; margin-top: 10px;">
                        '아니오'를 선택하면 새로운 단어장이 생성됩니다.
                    </p>
                    <div class="modal-buttons">
                        <button class="modal-btn yes" onclick="confirmVocabMerge(true)">예 (합치기)</button>
                        <button class="modal-btn no" onclick="confirmVocabMerge(false)">아니오 (새 단어장)</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 피드백 요소 -->
    <div class="feedback" id="feedback"></div>

    <!-- 다크모드 토글 -->
    <button class="dark-mode-toggle" onclick="toggleDarkMode()">🌙</button>

    <!-- 백업 파일 입력 -->
    <input type="file" id="backupInput" accept=".json">

    <script>
        // 전역 변수
        let appData = {
            vocabularies: {},
            currentVocabId: null,
            userStars: 1000,
            purchasedVocabs: [],
            globalMasteredWords: {},
            masteredWordIds: new Set(),
            globalSettings: {
                selectedVoice: '',
                wordTTS: true,
                exampleTTS: false,
                darkMode: false,
                studySpeed: 2.8,
                testWordTTS: true,
                testAnswerTTS: false,
                ttsPreload: 0,
                visibility: {
                    word: true,
                    pronunciation: true,
                    meaning: true,
                    example: true,
                    exampleMeaning: true
                }
            },
            version: 3
        };

        // 단어장 구조
        class Vocabulary {
            constructor(name) {
                this.id = Date.now().toString();
                this.name = name;
                this.createdAt = new Date().toISOString();
                this.lastStudiedAt = null;
                this.totalStudyTime = 0;
                this.studyStreak = 0;
                this.lastStreakDate = null;
                this.words = [];
                this.chapters = [];
                this.statistics = {
                    totalCorrect: 0,
                    totalAttempts: 0
                };
                this.settings = {
                    chapterSize: 10
                };
                this.weakWordsRecommendCount = 0;
                this.studyProgress = {
                    chapterIndex: -1,
                    cardIndex: 0
                };
                this.testProgress = {
                    chapterIndex: -1,
                    currentIndex: 0,
                    answers: [],
                    questions: []
                };
                this.price = 0;
            }
        }

        let currentVocab = null;
        let currentChapter = 0;
        let currentStudyIndex = 0;
        let currentTestIndex = 0;
        let studyInterval = null;
        let testTimer = null;
        let timerInterval = null;
        let isPaused = false;
        let isTestPaused = false;
        let isStudyMode = false;
        let isTestMode = false;
        let testQuestions = [];
        let testAnswers = [];
        let availableVoices = [];
        let selectedVoice = null;
        let currentUtterance = null;
        let isSpeaking = false;
        let waitingForTTS = false;
        let selectedChapterIndex = 0;
        let isResuming = false; 
        let preloadTimeout = null;
        let studyStartTime = null;
        let pendingFiles = null;
        let cleanupList = [];
        let pendingOnlineVocabData = null; // 온라인 단어장 임시 저장용
        let shouldMergeVocab = true; // 단어장 합치기 여부

        // 초기화
        document.addEventListener('DOMContentLoaded', function() {
            initializeVoices();
            loadSavedData();
            initSyncChannel(); // 동기화 채널 초기화
            
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            document.getElementById('backupInput').addEventListener('change', handleBackupUpload);
            
            // 체크박스 이벤트 리스너
            document.getElementById('wordMode').addEventListener('change', (e) => {
                appData.globalSettings.wordTTS = e.target.checked;
                checkBothTTSModes();
            });
            
            document.getElementById('exampleMode').addEventListener('change', (e) => {
                appData.globalSettings.exampleTTS = e.target.checked;
                checkBothTTSModes();
            });
            
            document.getElementById('testWordTTS').addEventListener('change', (e) => {
                appData.globalSettings.testWordTTS = e.target.checked;
            });
            
            document.getElementById('testAnswerTTS').addEventListener('change', (e) => {
                appData.globalSettings.testAnswerTTS = e.target.checked;
            });
            
            // 가시성 설정 이벤트 리스너
            document.getElementById('showWord').addEventListener('change', (e) => {
                appData.globalSettings.visibility.word = e.target.checked;
                updateStudyCardVisibility();
            });
            
            document.getElementById('showPronunciation').addEventListener('change', (e) => {
                appData.globalSettings.visibility.pronunciation = e.target.checked;
                updateStudyCardVisibility();
            });
            
            document.getElementById('showMeaning').addEventListener('change', (e) => {
                appData.globalSettings.visibility.meaning = e.target.checked;
                updateStudyCardVisibility();
            });
            
            document.getElementById('showExample').addEventListener('change', (e) => {
                appData.globalSettings.visibility.example = e.target.checked;
                updateStudyCardVisibility();
            });
            
            document.getElementById('showExampleMeaning').addEventListener('change', (e) => {
                appData.globalSettings.visibility.exampleMeaning = e.target.checked;
                updateStudyCardVisibility();
            });
            
            // 페이지 언로드 시 정리
            window.addEventListener('beforeunload', cleanup);
            
            // 탭 포커스 시 동기화 확인
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden && syncChannel) {
                    // 탭이 활성화되면 상태 요청
                    syncChannel.postMessage({
                        type: 'request-state',
                        tabId: tabId,
                        timestamp: Date.now()
                    });
                }
            });
        });

        // 리소스 정리
        function cleanup() {
            // 반짝이 인터벌 정리
            if (sparkleInterval) {
                clearInterval(sparkleInterval);
                sparkleInterval = null;
            }
            
            // 모든 타이머 정리
            if (studyInterval) clearInterval(studyInterval);
            if (testTimer) clearTimeout(testTimer);
            if (timerInterval) clearInterval(timerInterval);
            if (preloadTimeout) clearTimeout(preloadTimeout);
            
            // 음성 합성 중단
            speechSynthesis.cancel();
            
            // DOM 요소 정리
            cleanupList.forEach(element => {
                if (element && element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            });
            
            // 동기화 채널 정리
            if (syncChannel) {
                syncChannel.postMessage({
                    type: 'tab-closing',
                    tabId: tabId,
                    wasLeader: isLeaderTab,
                    timestamp: Date.now()
                });
                syncChannel.close();
            }
            
            // 전역 변수 정리
            pendingFiles = null;
            currentUtterance = null;
        }

        // 단어장 관련 함수들
        function showVocabModal() {
            displayVocabList();
            document.getElementById('vocabModal').style.display = 'flex';
        }

        function closeVocabModal() {
            document.getElementById('vocabModal').style.display = 'none';
        }

        function displayVocabList() {
            const vocabList = document.getElementById('vocabList');
            vocabList.innerHTML = '';
            
            Object.values(appData.vocabularies).forEach(vocab => {
                const item = document.createElement('div');
                item.className = 'vocab-item';
                if (vocab.id === appData.currentVocabId) {
                    item.classList.add('active');
                }
                
                const totalWords = vocab.words.length;
                const masteredWords = vocab.words.filter(w => w.weakness === 0 && w.correctCount >= 3).length;
                const progress = totalWords > 0 ? Math.round((masteredWords / totalWords) * 100) : 0;
                
                // 스트릭 계산
                const today = new Date().toDateString();
                const lastStudied = vocab.lastStudiedAt ? new Date(vocab.lastStudiedAt).toDateString() : null;
                let streakIcon = '💧';
                if (lastStudied === today) {
                    streakIcon = '🔥';
                } else if (vocab.studyStreak > 0) {
                    streakIcon = '❄️';
                }
                
item.innerHTML = `
                    <div class="vocab-item-info">
                        <div class="vocab-item-name">${vocab.name}</div>
                        <div class="vocab-item-stats">${totalWords}개 단어 • ${progress}% 완료</div>
                    </div>
                    <div class="vocab-item-progress">
                        <div class="vocab-progress-bar">
                            <div class="vocab-progress-fill" style="width: ${progress}%"></div>
                        </div>
                        <div class="vocab-streak">${streakIcon}</div>
                    </div>
                `;
                
                // 편집/삭제 버튼 추가
                const actionButtons = document.createElement('div');
                actionButtons.style.cssText = 'display: flex; gap: 8px; margin-left: 12px;';
                
                const editBtn = document.createElement('button');
                editBtn.innerHTML = '✏️';
                editBtn.style.cssText = 'background: transparent; border: none; font-size: 18px; cursor: pointer; padding: 4px;';
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    editVocabulary(vocab.id);
                };
                
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '🗑️';
                deleteBtn.style.cssText = 'background: transparent; border: none; font-size: 18px; cursor: pointer; padding: 4px;';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteVocabulary(vocab.id);
                };
                
                actionButtons.appendChild(editBtn);
                actionButtons.appendChild(deleteBtn);
                item.appendChild(actionButtons);
                
                item.onclick = () => selectVocabulary(vocab.id);
                vocabList.appendChild(item);            });
            
            if (Object.keys(appData.vocabularies).length === 0) {
                vocabList.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 40px;">단어장이 없습니다</div>';
            }
        }

        function filterVocabs(searchTerm) {
            const items = document.querySelectorAll('.vocab-item');
            items.forEach(item => {
                const name = item.querySelector('.vocab-item-name').textContent.toLowerCase();
                if (name.includes(searchTerm.toLowerCase())) {
                    item.style.display = 'flex';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        function createNewVocab() {
            closeVocabModal();
            document.getElementById('vocabNameModal').style.display = 'flex';
            document.getElementById('vocabNameInput').value = '';
            document.getElementById('vocabNameInput').focus();
        }

        function closeVocabNameModal() {
            document.getElementById('vocabNameModal').style.display = 'none';
        }

        function confirmVocabName() {
            const name = document.getElementById('vocabNameInput').value.trim();
            if (!name) {
                showFeedback('단어장 이름을 입력해주세요', 'error');
                return;
            }
            
            // 진행 중인 작업 중단
            if (isStudyMode) exitStudyMode();
            if (isTestMode) exitTestMode();
            
            const newVocab = new Vocabulary(name);
            appData.vocabularies[newVocab.id] = newVocab;
            appData.currentVocabId = newVocab.id;
            currentVocab = newVocab;
            
            closeVocabNameModal();
            updateUI();
            autoSave();
            showFeedback(`📚 '${name}' 단어장이 생성되었습니다`, 'success');
        }
        // 단어장 이름 편집
        function editVocabulary(vocabId) {
            const vocab = appData.vocabularies[vocabId];
            if (!vocab) return;
            
            const newName = prompt('새 단어장 이름을 입력하세요:', vocab.name);
            if (newName && newName.trim() && newName.trim() !== vocab.name) {
                vocab.name = newName.trim();
                
                // 현재 선택된 단어장이면 UI 업데이트
                if (vocabId === appData.currentVocabId) {
                    document.getElementById('currentVocabName').textContent = vocab.name;
                }
                
                displayVocabList();
                autoSave();
                showFeedback(`단어장 이름이 '${newName}'으로 변경되었습니다`, 'success');
            }
        }
        
        // 단어장 삭제
        function deleteVocabulary(vocabId) {
            const vocab = appData.vocabularies[vocabId];
            if (!vocab) return;
            // 기본 단어장 생성
        function createDefaultVocabulary() {
            const defaultVocab = new Vocabulary('기본 단어장');
            appData.vocabularies[defaultVocab.id] = defaultVocab;
            appData.currentVocabId = defaultVocab.id;
            currentVocab = defaultVocab;
        }
            // 단어장이 1개뿐이면 삭제 불가
            if (Object.keys(appData.vocabularies).length === 1) {
                showFeedback('마지막 단어장은 삭제할 수 없습니다', 'error');
                return;
            }
            
            // 단어가 있으면 확인
            if (vocab.words.length > 0) {
                if (!confirm(`'${vocab.name}'에는 ${vocab.words.length}개의 단어가 있습니다.\n정말 삭제하시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.`)) {
                    return;
                }
            } else {
                if (!confirm(`'${vocab.name}' 단어장을 삭제하시겠습니까?`)) {
                    return;
                }
            }
            
            // 삭제 실행
            delete appData.vocabularies[vocabId];
            
            // 현재 선택된 단어장이면 다른 단어장으로 전환
            if (vocabId === appData.currentVocabId) {
                const remainingVocabs = Object.keys(appData.vocabularies);
                if (remainingVocabs.length > 0) {
                    appData.currentVocabId = remainingVocabs[0];
                    currentVocab = appData.vocabularies[appData.currentVocabId];
                } else {
                    // 만약 없으면 기본 단어장 생성
                    createDefaultVocabulary();
                }
            }
            
            closeVocabModal();
            updateUI();
            autoSave();
            showFeedback(`'${vocab.name}' 단어장이 삭제되었습니다`, 'success');
        }

        function selectVocabulary(vocabId) {
            if (vocabId === appData.currentVocabId) {
                closeVocabModal();
                return;
            }

            // 진행 중인 작업 중단
            if (isStudyMode) exitStudyMode();
            if (isTestMode) exitTestMode();
            
            appData.currentVocabId = vocabId;
            currentVocab = appData.vocabularies[vocabId];
            
            closeVocabModal();
            updateUI();
            autoSave();
            
            // 단어장 전환 알림
            broadcastDataChange('vocab-switch', { vocabId: vocabId });
            
            showFeedback(`📚 '${currentVocab.name}' 단어장으로 전환했습니다`, 'success');
        }

        function updateVocabStreak() {
            if (!currentVocab) return;
            
            const today = new Date().toDateString();
            const lastStudied = currentVocab.lastStudiedAt ? new Date(currentVocab.lastStudiedAt).toDateString() : null;
            const lastStreak = currentVocab.lastStreakDate ? new Date(currentVocab.lastStreakDate).toDateString() : null;
            
            if (lastStudied !== today) {
                // 오늘 처음 학습
                currentVocab.lastStudiedAt = new Date().toISOString();
                
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toDateString();
                
                if (lastStreak === yesterdayStr) {
                    // 연속 학습
                    currentVocab.studyStreak++;
                } else {
                    // 연속 학습 끊김
                    currentVocab.studyStreak = 1;
                }
                
                currentVocab.lastStreakDate = new Date().toISOString();
            }
        }

        function updateUI() {
                // 복원 중이면 진행상황 체크 생략
            if (isResuming) {
                if (!currentVocab) {
                    document.getElementById('currentVocabName').textContent = '단어장 선택';
                    // ... 나머지 코드
                } else {
                    document.getElementById('currentVocabName').textContent = currentVocab.name;
                    updateStats();
                    if (document.getElementById('purchaseCount')) {
                        document.getElementById('purchaseCount').textContent = (appData.purchasedVocabs || []).length;
                    }
                    displayChapters();
                    updateWeakWordsList();
                }
                return;  // checkAndResumeProgress 호출하지 않음
            }
    
            if (!currentVocab) {
                document.getElementById('currentVocabName').textContent = '단어장 선택';
                document.getElementById('totalWords').textContent = '0';
                document.getElementById('weakWords').textContent = '0';
                document.getElementById('accuracy').textContent = '0%';
                document.getElementById('chapterList').innerHTML = '<div style="text-align: center; color: #6b7280; padding: 60px;">단어장을 선택하거나 새로 만들어주세요</div>';
                document.getElementById('weakWordsList').innerHTML = '<div style="text-align: center; color: #6b7280; padding: 40px;">약한 단어가 없습니다</div>';
                return;
            }
            
            document.getElementById('currentVocabName').textContent = currentVocab.name;
            updateStats();
            displayChapters();
            updateWeakWordsList();
            
            // 진행 중인 학습/테스트 자동 복원
            checkAndResumeProgress();
        }

        // 진행상황 체크 및 자동 복원
        // 진행상황 체크 및 자동 복원
        function checkAndResumeProgress() {
            if (!currentVocab || isResuming) return;
            
            // 현재 학습/테스트 모드가 아닐 때만 복원
            if (!isStudyMode && !isTestMode) {
                // 학습 진행상황 확인
                if (currentVocab.studyProgress && 
                    currentVocab.studyProgress.chapterIndex >= 0 && 
                    currentVocab.studyProgress.chapterIndex < currentVocab.chapters.length &&
                    currentVocab.studyProgress.cardIndex > 0) {
                    
                    isResuming = true;  // 플래그 설정
                    console.log('학습 진행상황 발견, 자동 복원 중...');
                    resumeStudy();
                    
                    // 1초 후 플래그 해제
                    setTimeout(() => {
                        isResuming = false;
                    }, 1000);
                    return;
                }
                
                // 테스트 진행상황 확인
                if (currentVocab.testProgress && 
                    currentVocab.testProgress.chapterIndex >= 0 && 
                    currentVocab.testProgress.chapterIndex < currentVocab.chapters.length &&
                    currentVocab.testProgress.currentIndex > 0 &&
                    currentVocab.testProgress.questions.length > 0) {
                    
                    isResuming = true;  // 플래그 설정
                    console.log('테스트 진행상황 발견, 자동 복원 중...');
                    resumeTest();
                    
                    // 1초 후 플래그 해제
                    setTimeout(() => {
                        isResuming = false;
                    }, 1000);
                    return;
                }
            }
        }
        // 학습 진행상황 복원
        function resumeStudy() {
            const progress = currentVocab.studyProgress;
            const chapter = currentVocab.chapters[progress.chapterIndex];
            
            if (!chapter) {
                console.error('복원할 챕터를 찾을 수 없습니다');
                // 진행상황 초기화
                currentVocab.studyProgress = { chapterIndex: -1, cardIndex: 0 };
                autoSave();
                return;
            }
            
            const chapterWords = getChapterWords(chapter);
            if (progress.cardIndex >= chapterWords.length) {
                console.error('진행상황이 유효하지 않습니다');
                // 진행상황 초기화
                currentVocab.studyProgress = { chapterIndex: -1, cardIndex: 0 };
                autoSave();
                return;
            }
            
            // 학습 상태 복원
            currentChapter = progress.chapterIndex;
            currentStudyIndex = progress.cardIndex;
            
            console.log(`학습 복원: 챕터 ${currentChapter + 1}, 카드 ${currentStudyIndex + 1}/${chapterWords.length}`);
            
            // 학습 모드 시작
            isStudyMode = true;
            isPaused = false;
            studyStartTime = Date.now();
            
            updateVocabStreak();
            document.getElementById('studyMode').style.display = 'flex';
            showCurrentStudyCard();
            startStudyTimer();
        }

        // 테스트 진행상황 복원
        function resumeTest() {
            const progress = currentVocab.testProgress;
            const chapter = currentVocab.chapters[progress.chapterIndex];
            
            if (!chapter) {
                console.error('복원할 테스트 챕터를 찾을 수 없습니다');
                // 진행상황 초기화
                currentVocab.testProgress = { chapterIndex: -1, currentIndex: 0, answers: [], questions: [] };
                autoSave();
                return;
            }
            
            if (progress.currentIndex >= progress.questions.length) {
                console.error('테스트 진행상황이 유효하지 않습니다');
                // 진행상황 초기화
                currentVocab.testProgress = { chapterIndex: -1, currentIndex: 0, answers: [], questions: [] };
                autoSave();
                return;
            }
            
            // 테스트 상태 복원
            currentChapter = progress.chapterIndex;
            currentTestIndex = progress.currentIndex;
            testAnswers = [...progress.answers];
            testQuestions = [...progress.questions];
            
            console.log(`테스트 복원: 챕터 ${currentChapter + 1}, 문제 ${currentTestIndex + 1}/${testQuestions.length}`);
            
            // 테스트 모드 시작
            isTestMode = true;
            isTestPaused = false;
            
            document.getElementById('testMode').style.display = 'flex';
            updateTestStats();
            showCurrentTestQuestion();
        }

        // IndexedDB 설정
        let db = null;
        const DB_NAME = 'WordMasterDB';
        const DB_VERSION = 1;

        // IndexedDB 초기화
        async function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => {
                    console.error('IndexedDB 열기 실패');
                    reject(request.error);
                };
                
                request.onsuccess = () => {
                    db = request.result;
                    console.log('IndexedDB 연결 성공');
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    
                    // 객체 저장소 생성
                    if (!db.objectStoreNames.contains('appData')) {
                        db.createObjectStore('appData');
                    }
                };
            });
        }

        // IndexedDB에 데이터 저장
        async function saveToIndexedDB(data) {
            if (!db) return false;
            
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['appData'], 'readwrite');
                const store = transaction.objectStore('appData');
                const request = store.put(data, 'mainData');
                
                request.onsuccess = () => {
                    console.log('IndexedDB 저장 성공');
                    resolve(true);
                };
                
                request.onerror = () => {
                    console.error('IndexedDB 저장 실패:', request.error);
                    reject(request.error);
                };
            });
        }

        // IndexedDB에서 데이터 로드
        async function loadFromIndexedDB() {
            if (!db) return null;
            
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['appData'], 'readonly');
                const store = transaction.objectStore('appData');
                const request = store.get('mainData');
                
                request.onsuccess = () => {
                    console.log('IndexedDB 로드 성공');
                    resolve(request.result);
                };
                
                request.onerror = () => {
                    console.error('IndexedDB 로드 실패:', request.error);
                    reject(request.error);
                };
            });
        }

        // 저장된 데이터 로드
        async function loadSavedData() {
            try {
                // IndexedDB 초기화
                await initIndexedDB();
                
                // IndexedDB에서 먼저 시도
                let data = await loadFromIndexedDB();
                
                // IndexedDB에 없으면 localStorage에서 시도
                if (!data) {
                    const saved = localStorage.getItem('wordMasterData');
                    if (saved) {
                        data = JSON.parse(saved);
                        // localStorage 데이터를 IndexedDB로 마이그레이션
                        await saveToIndexedDB(data);
                        console.log('localStorage 데이터를 IndexedDB로 마이그레이션 완료');
                    }
                }
                
                if (data) {
                    if (data.version === 3) {
                        appData = data;
                        // 별과 마스터 단어 초기화
                        if (!appData.userStars) appData.userStars = 1000;
                        if (!appData.purchasedVocabs) appData.purchasedVocabs = [];
                        if (!appData.globalMasteredWords) appData.globalMasteredWords = {};
                        if (!appData.masteredWordIds) appData.masteredWordIds = [];
                    } else {
                        
                        // 이전 버전 마이그레이션
                        migrateOldData(data);
                    }
                    
                    // 현재 단어장 설정
                    if (appData.currentVocabId && appData.vocabularies[appData.currentVocabId]) {
                        currentVocab = appData.vocabularies[appData.currentVocabId];
                    }
                    
                    // 글로벌 설정 복원
                    restoreGlobalSettings();
                }
                
                // 단어장이 하나도 없으면 기본 단어장 생성
                if (Object.keys(appData.vocabularies).length === 0) {
                    const defaultVocab = new Vocabulary('기본 단어장');
                    appData.vocabularies[defaultVocab.id] = defaultVocab;
                    appData.currentVocabId = defaultVocab.id;
                    currentVocab = defaultVocab;
                }
                
                updateUI();
            } catch (error) {
                console.error('Failed to load saved data:', error);
                showFeedback('저장된 데이터를 불러오는데 실패했습니다', 'error');
            }
        }

        // 이전 버전 데이터 마이그레이션
        function migrateOldData(oldData) {
            if (!oldData.words || oldData.words.length === 0) return;
            
            // 기본 단어장 생성
            const defaultVocab = new Vocabulary('기본 단어장');
            defaultVocab.words = oldData.words || [];
            defaultVocab.chapters = oldData.chapters || [];
            defaultVocab.statistics = oldData.statistics || { totalCorrect: 0, totalAttempts: 0 };
            defaultVocab.settings.chapterSize = oldData.settings?.chapterSize || 10;
            defaultVocab.weakWordsRecommendCount = oldData.weakWordsRecommendCount || 0;
            
            appData.vocabularies[defaultVocab.id] = defaultVocab;
            appData.currentVocabId = defaultVocab.id;
            
            // 글로벌 설정 마이그레이션
            if (oldData.settings) {
                appData.globalSettings = {
                    selectedVoice: oldData.settings.selectedVoice || '',
                    wordTTS: oldData.settings.wordTTS !== false,
                    exampleTTS: oldData.settings.exampleTTS === true,
                    darkMode: oldData.settings.darkMode === true,
                    studySpeed: oldData.settings.studySpeed || 2.8,
                    testWordTTS: oldData.settings.testWordTTS !== false,
                    testAnswerTTS: oldData.settings.testAnswerTTS === true,
                    ttsPreload: oldData.settings.ttsPreload || 0,
                    visibility: oldData.settings.visibility || {
                        word: true,
                        pronunciation: true,
                        meaning: true,
                        example: true,
                        exampleMeaning: true
                    }
                };
            }
        }

        // 글로벌 설정 복원
        function restoreGlobalSettings() {
            const settings = appData.globalSettings;
            
            // 음성 설정
            if (settings.selectedVoice) {
                document.getElementById('voiceSelect').value = settings.selectedVoice;
            }
            
            // 체크박스 설정
            document.getElementById('wordMode').checked = settings.wordTTS !== false;
            document.getElementById('exampleMode').checked = settings.exampleTTS === true;
            document.getElementById('testWordTTS').checked = settings.testWordTTS !== false;
            document.getElementById('testAnswerTTS').checked = settings.testAnswerTTS === true;
            
            // 슬라이더 설정
            document.getElementById('studySpeedSlider').value = settings.studySpeed * 10;
            updateStudySpeed();
            
            document.getElementById('ttsPreloadSlider').value = (settings.ttsPreload || 0) * 10;
            updateTTSPreload();
            
            // 가시성 설정
            if (settings.visibility) {
                document.getElementById('showWord').checked = settings.visibility.word !== false;
                document.getElementById('showPronunciation').checked = settings.visibility.pronunciation !== false;
                document.getElementById('showMeaning').checked = settings.visibility.meaning !== false;
                document.getElementById('showExample').checked = settings.visibility.example !== false;
                document.getElementById('showExampleMeaning').checked = settings.visibility.exampleMeaning !== false;
            }
            
            // 다크모드
            if (settings.darkMode) {
                document.body.classList.add('dark-mode');
                document.querySelector('.dark-mode-toggle').textContent = '☀️';
            }
        }

        // BroadcastChannel 설정
        let syncChannel = null;
        let tabId = Date.now().toString();
        let isLeaderTab = false;
        let lastSyncTime = Date.now();
        
        // BroadcastChannel 초기화
        function initSyncChannel() {
            try {
                syncChannel = new BroadcastChannel('word-master-sync');
                
                // 메시지 수신 처리
                syncChannel.onmessage = (event) => {
                    handleSyncMessage(event.data);
                };
                
                // 탭 활성화 알림
                announceTab();
                
                // 리더 선출
                requestLeaderElection();
                
                console.log('동기화 채널 초기화 완료:', tabId);
            } catch (error) {
                console.warn('BroadcastChannel을 지원하지 않는 브라우저입니다:', error);
            }
        }
        
        // 동기화 메시지 처리
        function handleSyncMessage(message) {
            switch (message.type) {
                case 'data-update':
                    if (message.tabId !== tabId && message.timestamp > lastSyncTime) {
                        handleRemoteDataUpdate(message);
                    }
                    break;
                    
                case 'tab-announce':
                    if (message.tabId !== tabId) {
                        // 다른 탭이 있음을 인지
                        if (isLeaderTab) {
                            sendCurrentState();
                        }
                    }
                    break;
                    
                case 'request-leader':
                    participateInLeaderElection();
                    break;
                    
                case 'leader-elected':
                    if (message.tabId !== tabId) {
                        isLeaderTab = false;
                    }
                    break;
                    
                case 'request-state':
                    if (isLeaderTab) {
                        sendCurrentState();
                    }
                    break;
                    
                case 'tab-closing':
                    if (message.wasLeader && message.tabId !== tabId) {
                        // 리더가 닫히면 새 리더 선출
                        setTimeout(requestLeaderElection, 100);
                    }
                    break;
            }
        }
        
        // 원격 데이터 업데이트 처리 - 진행상황 보호
        async function handleRemoteDataUpdate(message) {
            console.log('다른 탭에서 데이터 변경 감지:', message.changeType);
            
            // 복원 중이면 무시
            if (isResuming) {
                console.log('복원 중이므로 동기화 건너뜀');
                return;
            }
    
            // 진행 중인 작업 확인
            if (isStudyMode || isTestMode) {
                // 학습/테스트 중이면 경고만 표시하고 동기화하지 않음
                showFeedback('다른 탭에서 데이터가 변경되었습니다. 현재 작업 완료 후 동기화됩니다.', 'warning');
                return;
            }
            
            // 현재 진행상황 백업
            let studyProgressBackup = null;
            let testProgressBackup = null;
            
            if (currentVocab) {
                studyProgressBackup = { ...currentVocab.studyProgress };
                testProgressBackup = { ...currentVocab.testProgress };
            }
            
            // 데이터 동기화
            try {
                lastSyncTime = message.timestamp;
                
                if (message.fullData) {
                    // 전체 데이터 동기화
                    appData = message.fullData;
                    if (appData.currentVocabId && appData.vocabularies[appData.currentVocabId]) {
                        currentVocab = appData.vocabularies[appData.currentVocabId];
                        
                        // 진행상황 복원
                        if (studyProgressBackup && studyProgressBackup.chapterIndex >= 0) {
                            currentVocab.studyProgress = studyProgressBackup;
                        }
                        if (testProgressBackup && testProgressBackup.chapterIndex >= 0) {
                            currentVocab.testProgress = testProgressBackup;
                        }
                    }
                } else {
                    // 부분 업데이트
                    await loadFromIndexedDB();
                }
                
                // UI 업데이트
                updateUI();
                showFeedback('데이터가 동기화되었습니다', 'success');
            } catch (error) {
                console.error('동기화 실패:', error);
            }
        }
        
        // 탭 활성화 알림
        function announceTab() {
            if (syncChannel) {
                syncChannel.postMessage({
                    type: 'tab-announce',
                    tabId: tabId,
                    timestamp: Date.now()
                });
            }
        }
        
        // 리더 선출 요청
        function requestLeaderElection() {
            if (syncChannel) {
                isLeaderTab = true; // 일단 자신을 리더로 가정
                
                syncChannel.postMessage({
                    type: 'request-leader',
                    tabId: tabId,
                    timestamp: Date.now()
                });
                
                // 100ms 후에도 다른 리더가 없으면 자신이 리더
                setTimeout(() => {
                    if (isLeaderTab) {
                        syncChannel.postMessage({
                            type: 'leader-elected',
                            tabId: tabId,
                            timestamp: Date.now()
                        });
                        console.log('리더 탭으로 선출됨:', tabId);
                    }
                }, 100);
            }
        }
        
        // 리더 선출 참여
        function participateInLeaderElection() {
            if (syncChannel && isLeaderTab) {
                syncChannel.postMessage({
                    type: 'leader-elected',
                    tabId: tabId,
                    timestamp: Date.now()
                });
            }
        }
        
        // 현재 상태 전송
        function sendCurrentState() {
            if (syncChannel) {
                syncChannel.postMessage({
                    type: 'data-update',
                    tabId: tabId,
                    timestamp: Date.now(),
                    changeType: 'full-sync',
                    fullData: appData
                });
            }
        }
        
        // 데이터 변경 시 브로드캐스트
        function broadcastDataChange(changeType, details = {}) {
            if (syncChannel) {
                lastSyncTime = Date.now();
                
                const message = {
                    type: 'data-update',
                    tabId: tabId,
                    timestamp: lastSyncTime,
                    changeType: changeType,
                    details: details
                };
                
                // 중요한 변경사항은 전체 데이터 포함
                if (['vocab-switch', 'word-upload', 'reset'].includes(changeType)) {
                    message.fullData = appData;
                }
                
                syncChannel.postMessage(message);
            }
        }
        
        // 데이터 자동 저장 (동기화 포함)
        async function autoSave() {
            try {
                const dataStr = JSON.stringify(appData);
                
                // 크기 체크
                const sizeInMB = dataStr.length / (1024 * 1024);
                if (sizeInMB > 5) {
                    console.warn(`Data size: ${sizeInMB.toFixed(2)}MB exceeds recommended limit`);
                    
                    // 자동 백업 생성
                    await createAutoBackup();
                    
                    // 오래된 데이터 정리 제안
                    const oldestVocab = findOldestUnusedVocabulary();
                    if (oldestVocab) {
                        showFeedback(`저장 공간이 부족합니다. 오래된 단어장 '${oldestVocab.name}'을 삭제하거나 백업 후 정리해주세요.`, 'warning');
                    }
                    
                    // 그래도 저장은 시도
                }
                
                // IndexedDB에 저장
                if (db) {
                    await saveToIndexedDB(appData);
                } else {
                    // IndexedDB 사용 불가시 localStorage 폴백
                    localStorage.setItem('wordMasterData', dataStr);
                }
                
                // 다른 탭에 변경사항 알림
                broadcastDataChange('auto-save');
                
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    console.error('Storage quota exceeded');
                    
                    // 긴급 백업 시도
                    try {
                        await emergencyBackup();
                        showFeedback('저장 공간이 초과되어 긴급 백업을 생성했습니다. 다운로드 폴더를 확인해주세요.', 'error');
                    } catch (backupError) {
                        console.error('Emergency backup failed:', backupError);
                        showFeedback('저장 공간이 부족하고 백업도 실패했습니다. 즉시 수동으로 백업해주세요!', 'error');
                    }
                } else {
                    console.error('Failed to save data:', error);
                    showFeedback('데이터 저장에 실패했습니다', 'error');
                }
            }
        }
        
        // 자동 백업 생성
        async function createAutoBackup() {
            try {
                const backupData = {
                    ...appData,
                    backupInfo: {
                        timestamp: new Date().toISOString(),
                        reason: 'auto-backup-size-limit',
                        size: JSON.stringify(appData).length
                    }
                };
                
                // IndexedDB의 백업 저장소에 저장
                if (db) {
                    const transaction = db.transaction(['appData'], 'readwrite');
                    const store = transaction.objectStore('appData');
                    const backupKey = `backup_${Date.now()}`;
                    await store.put(backupData, backupKey);
                    
                    // 오래된 백업 정리 (최대 5개 유지)
                    await cleanOldBackups();
                }
            } catch (error) {
                console.error('Auto backup failed:', error);
            }
        }
        
        // 긴급 백업 (파일로 다운로드)
        async function emergencyBackup() {
            const backupData = {
                ...appData,
                backupInfo: {
                    timestamp: new Date().toISOString(),
                    reason: 'emergency-quota-exceeded',
                    size: JSON.stringify(appData).length
                }
            };
            
            const jsonString = JSON.stringify(backupData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `word_master_emergency_backup_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // 가장 오래되고 사용하지 않는 단어장 찾기
        function findOldestUnusedVocabulary() {
            const vocabs = Object.values(appData.vocabularies);
            if (vocabs.length <= 1) return null;
            
            // 마지막 학습일 기준 정렬
            const sortedVocabs = vocabs
                .filter(v => v.id !== appData.currentVocabId) // 현재 사용 중인 것 제외
                .sort((a, b) => {
                    const aDate = a.lastStudiedAt ? new Date(a.lastStudiedAt) : new Date(0);
                    const bDate = b.lastStudiedAt ? new Date(b.lastStudiedAt) : new Date(0);
                    return aDate - bDate;
                });
            
            return sortedVocabs[0];
        }
        
        // 오래된 백업 정리
        async function cleanOldBackups() {
            if (!db) return;
            
            try {
                const transaction = db.transaction(['appData'], 'readwrite');
                const store = transaction.objectStore('appData');
                const request = store.getAllKeys();
                
                request.onsuccess = async () => {
                    const keys = request.result;
                    const backupKeys = keys.filter(key => key.toString().startsWith('backup_'));
                    
                    // 시간순 정렬
                    backupKeys.sort((a, b) => {
                        const timeA = parseInt(a.toString().split('_')[1]);
                        const timeB = parseInt(b.toString().split('_')[1]);
                        return timeB - timeA; // 최신순
                    });
                    
                    // 5개 초과분 삭제
                    if (backupKeys.length > 5) {
                        const keysToDelete = backupKeys.slice(5);
                        for (const key of keysToDelete) {
                            await store.delete(key);
                        }
                        console.log(`Deleted ${keysToDelete.length} old backups`);
                    }
                };
            } catch (error) {
                console.error('Failed to clean old backups:', error);
            }
        }

        // 학습/테스트 진행상황 저장 - 개선된 버전
        function saveProgress() {
            if (!currentVocab) return;
            
            if (isStudyMode) {
                currentVocab.studyProgress = {
                    chapterIndex: currentChapter,
                    cardIndex: currentStudyIndex
                };
                console.log(`학습 진행상황 저장: 챕터 ${currentChapter}, 카드 ${currentStudyIndex}`);
            } else if (isTestMode) {
                currentVocab.testProgress = {
                    chapterIndex: currentChapter,
                    currentIndex: currentTestIndex,
                    answers: [...testAnswers],
                    questions: [...testQuestions]
                };
                console.log(`테스트 진행상황 저장: 챕터 ${currentChapter}, 문제 ${currentTestIndex}/${testQuestions.length}`);
            }
            autoSave();
        }

        // 양쪽 TTS 모드 체크
        function checkBothTTSModes() {
            const wordChecked = document.getElementById('wordMode').checked;
            const exampleChecked = document.getElementById('exampleMode').checked;
            
            if (wordChecked && exampleChecked) {
                showFeedback('단어와 예문을 모두 읽으면 학습이 느려질 수 있습니다', 'warning');
            }
            autoSave();
        }

        // 탭 전환
        function switchTab(tabName) {
            // 진행 중인 작업 확인
            if (isStudyMode || isTestMode) {
                if (!confirm('진행 중인 학습/테스트가 있습니다. 중단하시겠습니까?')) {
                    return;
                }
                if (isStudyMode) exitStudyMode();
                if (isTestMode) exitTestMode();
            }
            
            // 모든 탭과 컨텐츠 비활성화
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // 선택된 탭 활성화
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            
            if (tabName === 'chapters') {
                tabs[0].classList.add('active');
                tabContents[0].classList.add('active');
            } else if (tabName === 'weakwords') {
                tabs[1].classList.add('active');
                tabContents[1].classList.add('active');
            } else if (tabName === 'settings') {
                tabs[2].classList.add('active');
                tabContents[2].classList.add('active');
            }
        }

        // TTS 음성 초기화
        function initializeVoices() {
            function loadVoices() {
                availableVoices = speechSynthesis.getVoices();
                
                if (availableVoices.length > 0) {
                    updateVoiceSelector();
                    
                    // 자동 음성 선택
                    if (!appData.globalSettings.selectedVoice || appData.globalSettings.selectedVoice === '') {
                        autoSelectVoice();
                    } else {
                        // 저장된 음성 복원
                        const voice = availableVoices.find(v => v.name === appData.globalSettings.selectedVoice);
                        if (voice) {
                            selectedVoice = voice;
                            document.getElementById('voiceSelect').value = appData.globalSettings.selectedVoice;
                        } else {
                            autoSelectVoice();
                        }
                    }
                }
            }

            // Chrome은 즉시 음성 목록을 제공
            if (speechSynthesis.getVoices().length > 0) {
                loadVoices();
            } else {
                // 음성 목록이 나중에 로드되는 경우
                speechSynthesis.addEventListener('voiceschanged', loadVoices);
            }
        }

        // 자동 음성 선택
        function autoSelectVoice() {
            const userLang = navigator.language || 'ko-KR';
            let voice = availableVoices.find(v => v.lang === userLang);
            
            if (!voice) {
                // 언어 코드의 앞부분만 매칭
                const langPrefix = userLang.split('-')[0];
                voice = availableVoices.find(v => v.lang.startsWith(langPrefix));
            }
            
            if (!voice && availableVoices.length > 0) {
                // 기본값으로 첫 번째 음성 선택
                voice = availableVoices[0];
            }
            
            if (voice) {
                selectedVoice = voice;
                appData.globalSettings.selectedVoice = voice.name;
                document.getElementById('voiceSelect').value = voice.name;
            }
        }

        // 음성 선택기 업데이트
        function updateVoiceSelector() {
            const select = document.getElementById('voiceSelect');
            // 기존 옵션 제거 (첫 번째 제외)
            while (select.options.length > 1) {
                select.remove(1);
            }
            
            availableVoices.forEach((voice) => {
                const option = document.createElement('option');
                option.value = voice.name;
                option.textContent = `${voice.name} (${voice.lang})`;
                
                // 언어별 이모지 추가
                if (voice.lang.includes('ko')) option.textContent = '🇰🇷 ' + option.textContent;
                else if (voice.lang.includes('ja')) option.textContent = '🇯🇵 ' + option.textContent;
                else if (voice.lang.includes('en')) option.textContent = '🇺🇸 ' + option.textContent;
                else if (voice.lang.includes('zh')) option.textContent = '🇨🇳 ' + option.textContent;
                else if (voice.lang.includes('es')) option.textContent = '🇪🇸 ' + option.textContent;
                else if (voice.lang.includes('fr')) option.textContent = '🇫🇷 ' + option.textContent;
                else if (voice.lang.includes('de')) option.textContent = '🇩🇪 ' + option.textContent;
                else if (voice.lang.includes('it')) option.textContent = '🇮🇹 ' + option.textContent;
                else if (voice.lang.includes('pt')) option.textContent = '🇵🇹 ' + option.textContent;
                else if (voice.lang.includes('ru')) option.textContent = '🇷🇺 ' + option.textContent;
                
                select.appendChild(option);
            });
        }

        // 음성 변경
        function changeVoice() {
            const select = document.getElementById('voiceSelect');
            if (select.value === '') {
                autoSelectVoice();
            } else {
                selectedVoice = availableVoices.find(v => v.name === select.value);
                appData.globalSettings.selectedVoice = select.value;
            }
            autoSave();
        }

        // 음성 테스트
        function testVoice() {
            if (selectedVoice === null) {
                showFeedback('음성을 선택해주세요', 'error');
                return;
            }
            
            // 언어별 테스트 텍스트
            let testText = '안녕하세요, 음성 테스트입니다';
            const lang = selectedVoice.lang;
            
            if (lang.includes('en')) {
                testText = 'Hello, this is a voice test';
            } else if (lang.includes('ja')) {
                testText = 'こんにちは、音声テストです';
            } else if (lang.includes('zh')) {
                testText = '你好，这是语音测试';
            } else if (lang.includes('es')) {
                testText = 'Hola, esta es una prueba de voz';
            } else if (lang.includes('fr')) {
                testText = 'Bonjour, ceci est un test vocal';
            } else if (lang.includes('de')) {
                testText = 'Hallo, das ist ein Sprachtest';
            } else if (lang.includes('it')) {
                testText = 'Ciao, questo è un test vocale';
            } else if (lang.includes('pt')) {
                testText = 'Olá, este é um teste de voz';
            } else if (lang.includes('ru')) {
                testText = 'Привет, это голосовой тест';
            }
            
            speakTextWithCallback(testText, () => {});
        }

        // TTS 재생 (콜백 포함)
        function speakTextWithCallback(text, callback) {
            if (!selectedVoice || !text) {
                if (callback) callback();
                return;
            }
            
            try {
                // 기존 음성 즉시 중단
                speechSynthesis.cancel();
                isSpeaking = false;
                waitingForTTS = true;
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.voice = selectedVoice;
                utterance.rate = 0.9;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                
                currentUtterance = utterance;
                
                utterance.onstart = () => {
                    isSpeaking = true;
                };
                
                utterance.onend = () => {
                    isSpeaking = false;
                    currentUtterance = null;
                    waitingForTTS = false;
                    if (callback) callback();
                };
                
                utterance.onerror = (e) => {
                    console.warn('TTS 오류:', e);
                    isSpeaking = false;
                    currentUtterance = null;
                    waitingForTTS = false;
                    if (callback) callback();
                };
                
                speechSynthesis.speak(utterance);
            } catch (error) {
                console.error('TTS 재생 실패:', error);
                isSpeaking = false;
                waitingForTTS = false;
                if (callback) callback();
            }
        }

        // TTS 프리로드 (개선된 버전)
        function preloadTTS(text) {
            if (!selectedVoice || !text || appData.globalSettings.ttsPreload === 0) return;
            
            // 이전 프리로드 취소
            if (preloadTimeout) {
                clearTimeout(preloadTimeout);
                preloadTimeout = null;
            }
            
            // 프리로드 타이밍 계산
            const preloadTime = Math.max(0, appData.globalSettings.studySpeed * 1000 - appData.globalSettings.ttsPreload * 100);
            
            if (preloadTime > 0) {
                preloadTimeout = setTimeout(() => {
                    try {
                        // 프리로드용 utterance 생성
                        const preloadUtterance = new SpeechSynthesisUtterance(text);
                        preloadUtterance.voice = selectedVoice;
                        preloadUtterance.rate = 0.9;
                        preloadUtterance.pitch = 1.0;
                        preloadUtterance.volume = 0.001; // 거의 들리지 않는 볼륨
                        
                        // 프리로드 실행
                        speechSynthesis.speak(preloadUtterance);
                    } catch (error) {
                        console.error('TTS 프리로드 실패:', error);
                    }
                }, preloadTime);
            }
        }

        // 학습 속도 업데이트
        function updateStudySpeed() {
            const slider = document.getElementById('studySpeedSlider');
            const value = slider.value / 10;
            document.getElementById('studySpeedValue').textContent = value.toFixed(1) + '초';
            appData.globalSettings.studySpeed = value;
            autoSave();
        }

        // TTS 프리로드 설정 업데이트
        function updateTTSPreload() {
            const slider = document.getElementById('ttsPreloadSlider');
            const value = slider.value / 10;
            document.getElementById('ttsPreloadValue').textContent = value.toFixed(1) + '초';
            appData.globalSettings.ttsPreload = value;
            autoSave();
        }

        // 학습 카드 가시성 업데이트
        function updateStudyCardVisibility() {
            const elements = {
                word: document.getElementById('studyWordText'),
                pronunciation: document.getElementById('studyWordPronunciation'),
                meaning: document.getElementById('studyWordMeaning'),
                example: document.getElementById('studyWordExample'),
                exampleMeaning: document.getElementById('studyWordExampleMeaning')
            };
            
            Object.keys(elements).forEach(key => {
                if (elements[key]) {
                    if (appData.globalSettings.visibility[key]) {
                        elements[key].classList.remove('hidden');
                    } else {
                        elements[key].classList.add('hidden');
                    }
                }
            });
            
            autoSave();
        }

        // 파일 업로드 처리
        function handleFileUpload(event) {
            const files = event.target.files;
            if (files.length === 0) return;
            
            if (!currentVocab) {
                showFeedback('먼저 단어장을 선택하거나 만들어주세요', 'error');
                event.target.value = ''; // 입력 초기화
                return;
            }
            
            console.log('파일 업로드 시작:', files.length, '개 파일');
            
            // 파일을 배열로 변환하여 저장
            pendingFiles = Array.from(files);
            
            // 챕터 설정 모달 표시
            document.getElementById('chapterSettingModal').style.display = 'flex';
            document.getElementById('chapterSizeInput').value = currentVocab.settings.chapterSize;
        }

        // 백업 파일 업로드 처리
        function handleBackupUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // 진행 중인 작업 중단
                    if (isStudyMode) exitStudyMode();
                    if (isTestMode) exitTestMode();
                    
                    if (data.version === 3) {
                        // 새 버전 직접 로드
                        appData = data;
                        
                        // 현재 단어장 재설정
                        if (appData.currentVocabId && appData.vocabularies[appData.currentVocabId]) {
                            currentVocab = appData.vocabularies[appData.currentVocabId];
                        } else {
                            currentVocab = null;
                        }
                    } else if (data.version === 2) {
                        // 버전 2 마이그레이션
                        migrateV2Data(data);
                    } else {
                        // 구 버전 마이그레이션
                        migrateOldData(data);
                    }
                    
                    // 설정 복원
                    restoreGlobalSettings();
                    
                    // UI 업데이트
                    updateUI();
                    
                    // 파일 크기 표시
                    const sizeKB = (e.target.result.length / 1024).toFixed(2);
                    showFeedback(`📂 백업 데이터가 불러와졌습니다 (${sizeKB}KB)`, 'success');
                    
                    // 로컬 스토리지에도 저장
                    autoSave();
                    
                } catch (error) {
                    showFeedback('파일 형식이 올바르지 않습니다', 'error');
                    console.error('백업 데이터 로드 실패:', error);
                }
            };
            reader.readAsText(file);
            
            // 입력 초기화
            event.target.value = '';
        }

        // V2 데이터 마이그레이션 - 개선된 버전
        function migrateV2Data(v2Data) {
            // 기본 단어장 생성
            const defaultVocab = new Vocabulary('불러온 단어장');
            
            // 단어 복원 - ID 생성 로직 개선
            defaultVocab.words = v2Data.words.map((w, index) => {
                // 기존 ID가 있으면 사용, 없으면 안정적인 ID 생성
                const wordId = w.id || `migrated_word_${index}_${w.word?.replace(/[^a-zA-Z0-9]/g, '')}_${Date.now()}`;
                
                return {
                    id: wordId,
                    word: w.w || w.word,
                    meaning: w.m || w.meaning,
                    pronunciation: w.p || w.pronunciation || '',
                    example: w.e || w.example || '',
                    exampleMeaning: w.em || w.exampleMeaning || '',
                    weakness: w.wk || w.weakness || 0,
                    correctCount: w.cc || w.correctCount || 0,
                    totalAttempts: w.ta || w.totalAttempts || 0,
                    consecutiveCorrect: w.cs || w.consecutiveCorrect || 0,
                    lastCorrect: w.lc || w.lastCorrect || false,
                    source: w.src || w.source || 'imported'
                };
            });
            
            // 단어 ID 매핑 테이블 생성
            const wordIdMap = new Map();
            defaultVocab.words.forEach((word, index) => {
                if (v2Data.words[index]) {
                    const oldWord = v2Data.words[index];
                    const oldId = oldWord.id || oldWord.w || oldWord.word;
                    if (oldId) {
                        wordIdMap.set(oldId, word.id);
                    }
                }
            });
            
            // 챕터 복원 - ID 매핑 사용
            if (v2Data.chapters) {
                defaultVocab.chapters = v2Data.chapters.map(ch => {
                    let wordIds = [];
                    
                    if (ch.wordIds && Array.isArray(ch.wordIds)) {
                        // 기존 wordIds가 있는 경우
                        wordIds = ch.wordIds.map(oldId => wordIdMap.get(oldId) || oldId)
                            .filter(id => defaultVocab.words.find(w => w.id === id));
                    } else if (ch.words && Array.isArray(ch.words)) {
                        // words 배열에서 ID 추출
                        wordIds = ch.words.map(w => {
                            if (typeof w === 'string') {
                                // 단어 텍스트로 ID 찾기
                                const foundWord = defaultVocab.words.find(word => word.word === w);
                                return foundWord ? foundWord.id : null;
                            } else if (w && w.id) {
                                // 객체에서 ID 추출
                                return wordIdMap.get(w.id) || w.id;
                            } else if (w && w.word) {
                                // 단어 텍스트로 찾기
                                const foundWord = defaultVocab.words.find(word => word.word === w.word);
                                return foundWord ? foundWord.id : null;
                            }
                            return null;
                        }).filter(id => id && defaultVocab.words.find(w => w.id === id));
                    }
                    
                    return {
                        id: ch.id || `migrated_chapter_${Date.now()}_${Math.random()}`,
                        title: ch.title || '마이그레이션된 챕터',
                        wordIds: wordIds,
                        accuracy: ch.accuracy || 0,
                        stars: ch.stars || 0,
                        completedCount: ch.completedCount || 0,
                        type: ch.type || 'normal',
                        perfectScore: ch.perfectScore || false
                    };
                }).filter(ch => ch.wordIds.length > 0); // 빈 챕터 제거
            }
            
            // 통계 복원
            defaultVocab.statistics = {
                totalCorrect: v2Data.stats?.tc || v2Data.statistics?.totalCorrect || 0,
                totalAttempts: v2Data.stats?.ta || v2Data.statistics?.totalAttempts || 0
            };
            
            // 설정 복원
            defaultVocab.settings.chapterSize = v2Data.settings?.cs || v2Data.settings?.chapterSize || 10;
            defaultVocab.weakWordsRecommendCount = v2Data.wrc || v2Data.weakWordsRecommendCount || 0;
            
            // 글로벌 설정 복원
            if (v2Data.settings) {
                appData.globalSettings = {
                    selectedVoice: v2Data.settings.sv || v2Data.settings.selectedVoice || '',
                    wordTTS: v2Data.settings.wt !== false && v2Data.settings.wordTTS !== false,
                    exampleTTS: v2Data.settings.et === true || v2Data.settings.exampleTTS === true,
                    darkMode: v2Data.settings.dm === true || v2Data.settings.darkMode === true,
                    studySpeed: v2Data.settings.ss || v2Data.settings.studySpeed || 2.8,
                    testWordTTS: v2Data.settings.twt !== false && v2Data.settings.testWordTTS !== false,
                    testAnswerTTS: v2Data.settings.tat === true || v2Data.settings.testAnswerTTS === true,
                    ttsPreload: v2Data.settings.tp || v2Data.settings.ttsPreload || 0,
                    visibility: v2Data.settings.vs || v2Data.settings.visibility || {
                        word: true,
                        pronunciation: true,
                        meaning: true,
                        example: true,
                        exampleMeaning: true
                    }
                };
            }
            
            appData.vocabularies[defaultVocab.id] = defaultVocab;
            appData.currentVocabId = defaultVocab.id;
            currentVocab = defaultVocab;
            
            console.log(`마이그레이션 완료: ${defaultVocab.words.length}개 단어, ${defaultVocab.chapters.length}개 챕터`);
        }

        // 챕터 설정 확인
        function confirmChapterSetting() {
            const input = document.getElementById('chapterSizeInput');
            const chapterSize = parseInt(input.value);
            
            console.log('챕터 크기 설정:', chapterSize);
            
            if (isNaN(chapterSize) || chapterSize < 10 || chapterSize > 200) {
                showFeedback('10 ~ 200 사이의 값을 입력해주세요', 'error');
                return;
            }
            
            currentVocab.settings.chapterSize = chapterSize;
            document.getElementById('chapterSettingModal').style.display = 'none';
            
            // 온라인 단어장 처리
            if (pendingOnlineVocabData) {
                processOnlineVocab(pendingOnlineVocabData);
                pendingOnlineVocabData = null;
            } 
            // 파일 처리
            else if (pendingFiles && pendingFiles.length > 0) {
                processFiles(pendingFiles);
                pendingFiles = null;
            } else {
                console.error('처리할 데이터가 없습니다');
                showFeedback('데이터를 다시 선택해주세요', 'error');
            }
            
            // 파일 입력 초기화 (재업로드 가능하도록)
            document.getElementById('fileInput').value = '';
        }

        // 파일 처리
        function processFiles(files) {
            if (!files || files.length === 0) {
                console.error('처리할 파일이 없습니다');
                return;
            }
            
            let totalLoaded = 0;
            let filesProcessed = 0;
            const fileCount = files.length;
            
            console.log('파일 처리 시작:', fileCount, '개');
            
            files.forEach((file, index) => {
                console.log(`파일 ${index + 1} 처리 중:`, file.name);
                
                const reader = new FileReader();
                
                reader.onerror = function(e) {
                    console.error('파일 읽기 오류:', e);
                    filesProcessed++;
                    checkFileProcessingComplete();
                };
                
                reader.onload = function(e) {
                    try {
                        const content = e.target.result;
                        console.log(`파일 ${file.name} 내용 길이:`, content.length);
                        
                        const words = parseWordFile(content, file.name);
                        console.log(`파일 ${file.name}에서 ${words.length}개 단어 파싱됨`);
                        
                        // 중복 제거하며 추가
                        let addedCount = 0;
                        words.forEach(word => {
                            if (!currentVocab.words.find(w => w.word === word.word)) {
                                currentVocab.words.push({
                                    ...word,
                                    weakness: 0,
                                    correctCount: 0,
                                    totalAttempts: 0,
                                    consecutiveCorrect: 0,
                                    lastCorrect: false
                                });
                                addedCount++;
                            }
                        });
                        
                        console.log(`${addedCount}개 단어가 새로 추가됨`);
                        totalLoaded += addedCount;
                        
                    } catch (error) {
                        console.error('파일 처리 중 오류:', error);
                    }
                    
                    filesProcessed++;
                    checkFileProcessingComplete();
                };
                
                // 파일 처리 완료 체크
                function checkFileProcessingComplete() {
                    if (filesProcessed === fileCount) {
                        if (totalLoaded > 0) {
                            showFeedback(`✨ 총 ${totalLoaded}개의 단어를 로드했습니다!`, 'success');
                            createChapters();
                            updateStats();
                            autoSave();
                        } else {
                            showFeedback('로드된 단어가 없습니다. 파일 형식을 확인해주세요.', 'error');
                        }
                    }
                }
                
                // UTF-8로 파일 읽기
                reader.readAsText(file, 'UTF-8');
            });
        }

        // 단어 파일 파싱
        function parseWordFile(content, filename) {
            console.log('파일 파싱 시작:', filename);
            
            const lines = content.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);
            
            console.log('총 라인 수:', lines.length);
            
            const words = [];
            const timestamp = Date.now();
            
            lines.forEach((line, index) => {
                // 영어 패턴: word[pronunciation]: meaning + example @ example_meaning
                let match = line.match(/^(.+?)\[([^\]]+)\]\s*:\s*(.+?)\s*\+\s*(.+?)\s*@\s*(.+)$/);
                
                if (match) {
                    // 영어 형식
                    const word = match[1].trim();
                    const pronunciation = match[2].trim();
                    const meaning = match[3].trim();
                    const example = match[4].trim();
                    const exampleMeaning = match[5].trim();
                    
                    words.push({
                        id: `${word.trim().replace(/[^a-zA-Z0-9가-힣]/g, '_')}_${index}_${timestamp}`,
                        word: word,
                        pronunciation: pronunciation,
                        meaning: meaning,
                        example: example,
                        exampleMeaning: exampleMeaning,
                        source: filename
                    });
                } else {
                    // 기존 형식 시도: word: meaning + example
                    match = line.match(/^(.+?)\s*:\s*(.+?)\s*\+\s*(.+)$/) ||
                           line.match(/^(.+?):(.+?)\+(.+)$/);
                    
                    if (match) {
                        const word = match[1].trim();
                        const meaning = match[2].trim();
                        const example = match[3].trim();
                        
                        words.push({
                            id: `${filename}_${timestamp}_${index}`,
                            word: word,
                            pronunciation: '',
                            meaning: meaning,
                            example: example,
                            exampleMeaning: '',
                            source: filename
                        });
                    } else {
                        // 더 간단한 형식 시도: word: meaning
                        match = line.match(/^(.+?)\s*:\s*(.+)$/);
                        if (match) {
                            const word = match[1].trim();
                            const meaning = match[2].trim();
                            
                            words.push({
                                id: `${filename}_${timestamp}_${index}`,
                                word: word,
                                pronunciation: '',
                                meaning: meaning,
                                example: '',
                                exampleMeaning: '',
                                source: filename
                            });
                        } else {
                            console.warn(`라인 ${index + 1} 파싱 실패:`, line);
                        }
                    }
                }
            });
            
            console.log('파싱 완료. 단어 수:', words.length);
            return words;
        }

        // 챕터 생성 (계층적 시험 구조) - ID 기반으로 개선
        async function createChapters() {
            if (!currentVocab) return;
            
            // 진행률 표시
            showProgress('챕터 생성 중...', 0);
            
            // 기존 챕터의 진행상황 백업
            const progressBackup = backupChapterProgress();
            
            currentVocab.chapters = [];
            const chapterSize = currentVocab.settings.chapterSize;
            const totalWords = currentVocab.words.length;
            
            // 대용량 처리를 위한 청크 설정
            const CHUNK_SIZE = 1000; // 한 번에 처리할 단어 수
            let processedWords = 0;
            
            let chapterNumber = 1;
            let currentIndex = 0;
            let midtermCount = 0;
            let finalCount = 0;
            let comprehensiveCount = 0;
            
            // 청크 단위로 처리
            while (currentIndex < totalWords) {
                const chunkEnd = Math.min(currentIndex + CHUNK_SIZE, totalWords);
                
                // 이 청크에서 처리할 챕터들 생성
                while (currentIndex < chunkEnd && currentIndex < totalWords) {
                    const sectionNumber = Math.floor((chapterNumber - 1) / 5);
                    const positionInSection = (chapterNumber - 1) % 5 + 1;
                    
                    // 각 섹션의 시작 인덱스
                    const sectionStartIndex = sectionNumber * 5 * chapterSize;
                    
                    // 현재 챕터가 포함할 단어들
                    const endIndex = Math.min(sectionStartIndex + positionInSection * chapterSize, totalWords);
                    
                    if (endIndex > currentIndex) {
                        const chapterWordIds = currentVocab.words
                            .slice(sectionStartIndex, endIndex)
                            .map(word => word.id);
                        
                        if (chapterWordIds.length > 0) {
                            const chapterId = `chapter_${chapterNumber}`;
                            currentVocab.chapters.push({
                                id: chapterId,
                                title: `챕터 ${chapterNumber}`,
                                wordIds: chapterWordIds,
                                accuracy: progressBackup[chapterId]?.accuracy || 0,
                                stars: progressBackup[chapterId]?.stars || 0,
                                completedCount: progressBackup[chapterId]?.completedCount || 0,
                                type: 'normal',
                                perfectScore: progressBackup[chapterId]?.perfectScore || false
                            });
                            currentIndex = endIndex;
                            processedWords = endIndex;
                        }
                        
                        // 10의 배수마다 시험 추가
                        if (chapterNumber % 10 === 0) {
                            await createExamChapters(chapterNumber, chapterSize, totalWords, 
                                                   progressBackup, midtermCount, finalCount, 
                                                   comprehensiveCount);
                        }
                        
                        chapterNumber++;
                    } else {
                        break;
                    }
                }
                
                // 진행률 업데이트
                const progress = Math.round((processedWords / totalWords) * 90); // 90%까지는 챕터 생성
                showProgress('챕터 생성 중...', progress);
                
                // 브라우저가 멈추지 않도록 잠시 제어권 양보
                await new Promise(resolve => requestAnimationFrame(resolve));
            }
            
            // 모든단어고사 (맨 마지막) - 대용량인 경우 제외
            if (currentVocab.words.length > 0 && currentVocab.words.length <= 5000) {
                const allWordsId = 'all_words_exam';
                currentVocab.chapters.push({
                    id: allWordsId,
                    title: '✨ 모든단어고사 ✨',
                    wordIds: currentVocab.words.map(w => w.id),
                    accuracy: progressBackup[allWordsId]?.accuracy || 0,
                    stars: progressBackup[allWordsId]?.stars || 0,
                    completedCount: progressBackup[allWordsId]?.completedCount || 0,
                    type: 'allwords',
                    perfectScore: progressBackup[allWordsId]?.perfectScore || false
                });
            } else if (currentVocab.words.length > 5000) {
                // 5000개 초과 시 안내 메시지만
                console.log('단어가 5000개를 초과하여 모든단어고사는 생성하지 않습니다.');
            }
            
            showProgress('챕터 표시 중...', 95);
            
            // 챕터 표시도 비동기로
            await new Promise(resolve => {
                requestAnimationFrame(() => {
                    displayChapters();
                    resolve();
                });
            });
            
            hideProgress();
        }
        
        // 시험 챕터 생성 (별도 함수로 분리) - 카운터 문제 해결
        async function createExamChapters(chapterNumber, chapterSize, totalWords, 
                                        progressBackup, midtermCount, finalCount, 
                                        comprehensiveCount) {
            const cycleNumber = Math.floor((chapterNumber - 1) / 60);
            const positionInCycle = chapterNumber % 60;
            
            if (positionInCycle === 10 || positionInCycle === 20) {
                // 중간고사
                const currentMidtermCount = Math.floor((chapterNumber - 1) / 10);
                const examEndIndex = Math.min(chapterNumber * chapterSize, totalWords);
                const examWordIds = currentVocab.words
                    .slice(cycleNumber * 60 * chapterSize, examEndIndex)
                    .map(word => word.id);
                
                if (examWordIds.length > 0) {
                    const examId = `midterm_${currentMidtermCount + 1}`;
                    currentVocab.chapters.push({
                        id: examId,
                        title: `중간고사 ${currentMidtermCount + 1}`,
                        wordIds: examWordIds,
                        accuracy: progressBackup[examId]?.accuracy || 0,
                        stars: progressBackup[examId]?.stars || 0,
                        completedCount: progressBackup[examId]?.completedCount || 0,
                        type: 'midterm',
                        perfectScore: progressBackup[examId]?.perfectScore || false
                    });
                }
            } else if (positionInCycle === 30 || positionInCycle === 50) {
                // 기말고사
                const currentFinalCount = Math.floor((chapterNumber - 1) / 20);
                const examEndIndex = Math.min(chapterNumber * chapterSize, totalWords);
                const examWordIds = currentVocab.words
                    .slice(cycleNumber * 60 * chapterSize, examEndIndex)
                    .map(word => word.id);
                
                if (examWordIds.length > 0) {
                    const examId = `final_${currentFinalCount + 1}`;
                    currentVocab.chapters.push({
                        id: examId,
                        title: `기말고사 ${currentFinalCount + 1}`,
                        wordIds: examWordIds,
                        accuracy: progressBackup[examId]?.accuracy || 0,
                        stars: progressBackup[examId]?.stars || 0,
                        completedCount: progressBackup[examId]?.completedCount || 0,
                        type: 'final',
                        perfectScore: progressBackup[examId]?.perfectScore || false
                    });
                }
            } else if (positionInCycle === 0 && chapterNumber > 0) {
                // 종합고사 (60개 챕터마다)
                const currentComprehensiveCount = Math.floor(chapterNumber / 60);
                const examEndIndex = Math.min(chapterNumber * chapterSize, totalWords);
                const examWordIds = currentVocab.words
                    .slice(0, examEndIndex)
                    .map(word => word.id);
                
                if (examWordIds.length > 0) {
                    const examId = `comprehensive_${currentComprehensiveCount}`;
                    currentVocab.chapters.push({
                        id: examId,
                        title: `종합고사 ${currentComprehensiveCount}`,
                        wordIds: examWordIds,
                        accuracy: progressBackup[examId]?.accuracy || 0,
                        stars: progressBackup[examId]?.stars || 0,
                        completedCount: progressBackup[examId]?.completedCount || 0,
                        type: 'comprehensive',
                        perfectScore: progressBackup[examId]?.perfectScore || false
                    });
                }
            }
        }
        
        // 진행률 표시 함수
        function showProgress(message, percent) {
            let progressElement = document.getElementById('progress-overlay');
            if (!progressElement) {
                progressElement = document.createElement('div');
                progressElement.id = 'progress-overlay';
                progressElement.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    z-index: 9999;
                `;
                
                progressElement.innerHTML = `
                    <div style="background: white; padding: 30px; border-radius: 15px; text-align: center;">
                        <h3 style="margin-bottom: 20px; color: #333;" id="progress-message">${message}</h3>
                        <div style="width: 300px; height: 20px; background: #e0e0e0; border-radius: 10px; overflow: hidden;">
                            <div id="progress-bar" style="width: ${percent}%; height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); transition: width 0.3s ease;"></div>
                        </div>
                        <div style="margin-top: 10px; color: #666;" id="progress-percent">${percent}%</div>
                    </div>
                `;
                
                document.body.appendChild(progressElement);
            } else {
                document.getElementById('progress-message').textContent = message;
                document.getElementById('progress-bar').style.width = percent + '%';
                document.getElementById('progress-percent').textContent = percent + '%';
            }
        }
        
        // 진행률 숨기기
        function hideProgress() {
            const progressElement = document.getElementById('progress-overlay');
            if (progressElement) {
                progressElement.remove();
            }
        }
        
        // 챕터 진행상황 백업
        function backupChapterProgress() {
            const backup = {};
            if (currentVocab && currentVocab.chapters) {
                currentVocab.chapters.forEach(chapter => {
                    backup[chapter.id] = {
                        accuracy: chapter.accuracy,
                        stars: chapter.stars,
                        completedCount: chapter.completedCount,
                        perfectScore: chapter.perfectScore
                    };
                });
            }
            return backup;
        }
        
        // 챕터의 단어들 가져오기 (ID로 조회) - 개선된 버전
        function getChapterWords(chapter) {
            if (!chapter) {
                console.warn('Chapter is null or undefined');
                return [];
            }
            
            if (!chapter.wordIds || !Array.isArray(chapter.wordIds)) {
                console.warn('Chapter has no wordIds or wordIds is not an array:', chapter);
                return [];
            }
            
            if (!currentVocab || !currentVocab.words) {
                console.warn('Current vocab or vocab words is not available');
                return [];
            }
            
            const words = [];
            const invalidIds = [];
            
            chapter.wordIds.forEach(wordId => {
                const word = currentVocab.words.find(w => w.id === wordId);
                if (word) {
                    words.push(word);
                } else {
                    invalidIds.push(wordId);
                }
            });
            
            // 유효하지 않은 ID가 있으면 경고하고 정리
            if (invalidIds.length > 0) {
                console.warn(`Invalid word IDs found in chapter ${chapter.title}:`, invalidIds);
                console.warn(`Total wordIds: ${chapter.wordIds.length}, Valid: ${words.length}, Invalid: ${invalidIds.length}`);
                
                // 유효하지 않은 ID 제거
                chapter.wordIds = chapter.wordIds.filter(id => !invalidIds.includes(id));
                
                // 만약 모든 ID가 유효하지 않다면 에러 로그
                if (words.length === 0 && chapter.wordIds.length > 0) {
                    console.error(`All word IDs in chapter ${chapter.title} are invalid!`);
                }
            }
            
            return words;
        }
        
        // 챕터 무결성 검증
        function validateChapters() {
            if (!currentVocab || !currentVocab.chapters) return;
            
            let hasInvalidIds = false;
            
            currentVocab.chapters.forEach(chapter => {
                if (chapter.wordIds) {
                    const validIds = [];
                    chapter.wordIds.forEach(wordId => {
                        if (currentVocab.words.find(w => w.id === wordId)) {
                            validIds.push(wordId);
                        } else {
                            hasInvalidIds = true;
                        }
                    });
                    chapter.wordIds = validIds;
                }
            });
            
            if (hasInvalidIds) {
                console.log('챕터 무결성 검증 완료 - 유효하지 않은 단어 ID 제거됨');
                autoSave();
            }
        }

        // 챕터 표시 - 이벤트 리스너 중복 방지
        function displayChapters() {
            const chapterList = document.getElementById('chapterList');
            
            if (!currentVocab || currentVocab.chapters.length === 0) {
                chapterList.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 60px;">단어를 업로드해주세요</div>';
                return;
            }
            
            // 무결성 검증
            validateChapters();
            
            // 기존 내용 및 이벤트 리스너 제거
            chapterList.innerHTML = '';
            chapterList.onscroll = null; // 기존 스크롤 이벤트 제거
            
            // 한 번에 표시할 챕터 수
            const VISIBLE_CHAPTERS = 20;
            const totalChapters = currentVocab.chapters.length;
            let visibleStart = 0;
            let visibleEnd = Math.min(VISIBLE_CHAPTERS, totalChapters);
            
            // 챕터 컨테이너 생성
            const chaptersContainer = document.createElement('div');
            chaptersContainer.style.cssText = 'position: relative;';
            
            // 가상 높이를 위한 스페이서
            const spacerTop = document.createElement('div');
            const spacerBottom = document.createElement('div');
            
            // 챕터 높이 추정 (모바일/데스크톱 구분)
            const isMobile = window.innerWidth <= 768;
            const CHAPTER_HEIGHT = isMobile ? 150 : 180;
            
            // 스크롤 이벤트 핸들러
            let scrollTimeout;
            const handleScroll = () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    const scrollTop = chapterList.scrollTop;
                    const newStart = Math.floor(scrollTop / CHAPTER_HEIGHT);
                    const newEnd = Math.min(newStart + VISIBLE_CHAPTERS, totalChapters);
                    
                    if (newStart !== visibleStart || newEnd !== visibleEnd) {
                        visibleStart = Math.max(0, newStart - 5); // 버퍼 추가
                        visibleEnd = Math.min(newEnd + 5, totalChapters);
                        renderVisibleChapters();
                    }
                }, 50);
            };
            
            // 보이는 챕터만 렌더링
            const renderVisibleChapters = () => {
                // 기존 챕터 카드 제거
                chaptersContainer.innerHTML = '';
                
                // 상단 스페이서 높이 설정
                spacerTop.style.height = `${visibleStart * CHAPTER_HEIGHT}px`;
                
                // 보이는 챕터만 생성
                for (let index = visibleStart; index < visibleEnd; index++) {
                    const chapter = currentVocab.chapters[index];
                    const chapterCard = createChapterCard(chapter, index);
                    chaptersContainer.appendChild(chapterCard);
                }
                
                // 하단 스페이서 높이 설정
                const remainingChapters = totalChapters - visibleEnd;
                spacerBottom.style.height = `${remainingChapters * CHAPTER_HEIGHT}px`;
            };
            
            // 챕터 카드 생성 함수
            const createChapterCard = (chapter, index) => {
                const chapterCard = document.createElement('div');
                chapterCard.className = `chapter-card ${chapter.type}`;
                if (chapter.perfectScore) {
                    chapterCard.className += ' perfect';
                }
                chapterCard.onclick = () => showChapterModal(index);
                
                let starsDisplay = '';
                if (chapter.perfectScore) {
                    starsDisplay = '<span class="rainbow-star">⭐</span><span class="rainbow-star">⭐</span><span class="rainbow-star">⭐</span>';
                } else {
                    const stars = '⭐'.repeat(chapter.stars);
                    starsDisplay = stars || '☆☆☆';
                }
                
                // 챕터의 단어들 가져오기
                const chapterWords = getChapterWords(chapter);
                
                // 진행률 계산
                let masteredWords = 0;
                let recentCorrectWords = 0;
                
                for (const word of chapterWords) {
                    if (word.weakness === 0 && word.correctCount >= 3) masteredWords++;
                    if (word.lastCorrect) recentCorrectWords++;
                }
                
                const progressPercent = chapterWords.length > 0 ? (masteredWords / chapterWords.length) * 100 : 0;
                const recentProgressPercent = chapterWords.length > 0 ? (recentCorrectWords / chapterWords.length) * 100 : 0;
                
                chapterCard.innerHTML = `
                    <div class="chapter-header">
                        <div class="chapter-title">${chapter.title}</div>
                        <div class="chapter-stars">${starsDisplay}</div>
                    </div>
                    <div class="chapter-progress">
                        <div class="progress-info">
                            마스터 단어: ${masteredWords}/${chapterWords.length} • 최근 맞춘 단어: ${recentCorrectWords}/${chapterWords.length}
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-recent" style="width: ${recentProgressPercent}%"></div>
                            <div class="progress-bar-fill" style="width: ${progressPercent}%"></div>
                        </div>
                    </div>
                    <div class="chapter-info">
                        총 ${chapterWords.length}개 단어 • 정확도 ${chapter.accuracy}%<br>
                        완료 ${chapter.completedCount}회
                    </div>
                `;
                
                return chapterCard;
            };
            
            // 대용량 챕터 처리
            if (totalChapters > 100) {
                // 가상 스크롤링 사용
                chapterList.style.cssText = 'overflow-y: auto; max-height: calc(100vh - 300px);';
                chapterList.appendChild(spacerTop);
                chapterList.appendChild(chaptersContainer);
                chapterList.appendChild(spacerBottom);
                
                // 스크롤 이벤트 리스너 추가 (중복 방지)
                chapterList.addEventListener('scroll', handleScroll, { passive: true });
                
                // 초기 렌더링
                renderVisibleChapters();
                
                // 전체 높이 설정
                const totalHeight = totalChapters * CHAPTER_HEIGHT;
                chapterList.style.height = `${Math.min(totalHeight, window.innerHeight - 300)}px`;
            } else {
                // 100개 이하는 기존 방식
                currentVocab.chapters.forEach((chapter, index) => {
                    const chapterCard = createChapterCard(chapter, index);
                    chapterList.appendChild(chapterCard);
                });
            }
        }

        // 챕터 모달 표시
        function showChapterModal(index) {
            if (index < 0 || index >= currentVocab.chapters.length) return;
            
            selectedChapterIndex = index;
            const chapter = currentVocab.chapters[index];
            document.getElementById('chapterModalTitle').textContent = chapter.title;
            document.getElementById('chapterModal').style.display = 'flex';
        }

        // 챕터 모달 닫기
        function closeChapterModal() {
            document.getElementById('chapterModal').style.display = 'none';
        }

        // 모달에서 학습 시작 - 자동 복원 제거
        function startStudyFromModal() {
            closeChapterModal();
            startStudy(selectedChapterIndex);
        }

        // 모달에서 테스트 시작 - 자동 복원 제거
        function startTestFromModal() {
            closeChapterModal();
            startTest(selectedChapterIndex);
        }

        // 학습 모드 시작 - 개선된 버전
        function startStudy(chapterIndex) {
            if (chapterIndex < 0 || chapterIndex >= currentVocab.chapters.length) return;
            
            // 기존 진행상황이 다른 챕터면 초기화
            if (currentVocab.studyProgress.chapterIndex !== chapterIndex) {
                currentVocab.studyProgress = { chapterIndex: chapterIndex, cardIndex: 0 };
                currentStudyIndex = 0;
            } else {
                // 같은 챕터면 이어서 진행
                currentStudyIndex = currentVocab.studyProgress.cardIndex || 0;
            }
            
            currentChapter = chapterIndex;
            isStudyMode = true;
            isPaused = false;
            studyStartTime = Date.now();
            
            // 스트릭 업데이트
            updateVocabStreak();
            
            document.getElementById('studyMode').style.display = 'flex';
            
            showCurrentStudyCard();
            startStudyTimer();
        }

        // 학습 카드 표시
        function showCurrentStudyCard() {
            const chapter = currentVocab.chapters[currentChapter];
            if (!chapter) return;
            
            const chapterWords = getChapterWords(chapter);
            if (currentStudyIndex >= chapterWords.length) return;
            
            const word = chapterWords[currentStudyIndex];
            
            document.getElementById('studyWordText').textContent = word.word;
            document.getElementById('studyWordPronunciation').textContent = word.pronunciation ? `[${word.pronunciation}]` : '';
            document.getElementById('studyWordMeaning').textContent = word.meaning;
            
            // 예문 처리
            if (word.example) {
                document.getElementById('studyWordExample').textContent = word.example;
                document.getElementById('studyWordExample').style.display = 'block';
            } else {
                document.getElementById('studyWordExample').style.display = 'none';
            }
            
            // 예문 뜻 처리
            if (word.exampleMeaning) {
                document.getElementById('studyWordExampleMeaning').textContent = word.exampleMeaning;
                document.getElementById('studyWordExampleMeaning').style.display = 'block';
            } else {
                document.getElementById('studyWordExampleMeaning').style.display = 'none';
            }
            
            // 가시성 업데이트
            updateStudyCardVisibility();
            
            // 진행률 업데이트
            const progress = ((currentStudyIndex + 1) / chapterWords.length) * 100;
            document.getElementById('studyProgress').style.width = progress + '%';
            
            // TTS 재생
            if (selectedVoice) {
                let textToSpeak = '';
                
                if (appData.globalSettings.wordTTS) {
                    textToSpeak = word.word;
                }
                
                if (appData.globalSettings.exampleTTS && word.example) {
                    if (textToSpeak) textToSpeak += '. ';
                    textToSpeak += word.example;
                }
                
                if (textToSpeak) {
                    speakTextWithCallback(textToSpeak, () => {});
                }
            }
            
            // 다음 카드 프리로드
            if (appData.globalSettings.ttsPreload > 0) {
                const nextIndex = (currentStudyIndex + 1) % chapterWords.length;
                const nextWord = chapterWords[nextIndex];
                if (nextWord && selectedVoice) {
                    let nextText = '';
                    
                    if (appData.globalSettings.wordTTS) {
                        nextText = nextWord.word;
                    }
                    
                    if (appData.globalSettings.exampleTTS && nextWord.example) {
                        if (nextText) nextText += '. ';
                        nextText += nextWord.example;
                    }
                    
                    if (nextText) {
                        preloadTTS(nextText);
                    }
                }
            }
            
            saveProgress();
        }

        // 학습 타이머 시작
        function startStudyTimer() {
            if (studyInterval) clearInterval(studyInterval);
            
            const intervalTime = appData.globalSettings.studySpeed * 1000;
            
            studyInterval = setInterval(() => {
                if (!isPaused && !isSpeaking) {
                    nextStudyCard();
                }
            }, intervalTime);
        }

        // 다음 학습 카드
        function nextStudyCard() {
            const chapter = currentVocab.chapters[currentChapter];
            if (!chapter) return;
            
            const chapterWords = getChapterWords(chapter);
            currentStudyIndex = (currentStudyIndex + 1) % chapterWords.length;
            
            // 한 바퀴 돌았을 때
            if (currentStudyIndex === 0) {
                currentVocab.chapters[currentChapter].completedCount++;
                autoSave();
            }
            
            showCurrentStudyCard();
        }

        // 학습 일시정지/재개
        function toggleStudyPause() {
            isPaused = !isPaused;
            const pauseIndicator = document.getElementById('pauseIndicator');
            
            if (isPaused) {
                pauseIndicator.classList.remove('hidden');
                pauseIndicator.style.animation = 'pauseFadeInOut 1s ease-out';
                speechSynthesis.cancel();
                if (preloadTimeout) {
                    clearTimeout(preloadTimeout);
                    preloadTimeout = null;
                }
                
                setTimeout(() => {
                    pauseIndicator.classList.add('hidden');
                }, 1000);
            }
        }

        // 학습 모드 종료 - 진행상황 유지
        function exitStudyMode() {
            if (studyInterval) {
                clearInterval(studyInterval);
                studyInterval = null;
            }
            if (preloadTimeout) {
                clearTimeout(preloadTimeout);
                preloadTimeout = null;
            }
            speechSynthesis.cancel();
            document.getElementById('studyMode').style.display = 'none';
            isStudyMode = false;
            isPaused = false;
            document.getElementById('pauseIndicator').classList.add('hidden');
            
            // 학습 시간 업데이트
            if (studyStartTime) {
                const studyTime = Math.floor((Date.now() - studyStartTime) / 1000);
                currentVocab.totalStudyTime += studyTime;
                studyStartTime = null;
            }
            
            // 진행상황 저장 (진행상황을 유지하기 위해 초기화하지 않음)
            saveProgress();
            displayChapters();
            autoSave();
        }

        // 테스트 모드 시작 - 개선된 버전
        function startTest(chapterIndex, resume = false) {
            if (chapterIndex < 0 || chapterIndex >= currentVocab.chapters.length) return;
            
            currentChapter = chapterIndex;
            isTestMode = true;
            isTestPaused = false;
            
            if (!resume) {
                // 기존 진행상황이 같은 챕터면 이어서 진행
                if (currentVocab.testProgress.chapterIndex === chapterIndex && 
                    currentVocab.testProgress.currentIndex > 0 &&
                    currentVocab.testProgress.questions.length > 0) {
                    
                    currentTestIndex = currentVocab.testProgress.currentIndex;
                    testAnswers = [...currentVocab.testProgress.answers];
                    testQuestions = [...currentVocab.testProgress.questions];
                    
                    console.log(`테스트 이어서 진행: ${currentTestIndex + 1}/${testQuestions.length}`);
                } else {
                    // 새로 시작
                    currentTestIndex = 0;
                    testAnswers = [];
                    const chapter = currentVocab.chapters[currentChapter];
                    
                    // 챕터의 단어 ID 배열 가져오기
                    const chapterData = chapter.wordIds;
                    
                    // 우선순위 기반 문제 생성
                    testQuestions = generatePrioritizedQuestions(chapterData);
                    
                    // 진행상황 초기화
                    currentVocab.testProgress = {
                        chapterIndex: chapterIndex,
                        currentIndex: 0,
                        answers: [],
                        questions: [...testQuestions]
                    };
                }
            }
            
            document.getElementById('testMode').style.display = 'flex';
            updateTestStats();
            showCurrentTestQuestion();
        }
        
        // 우선순위 기반 문제 생성
        function generatePrioritizedQuestions(chapterData) {
            // 챕터 타입에 따른 최대 문제 수 설정
            const chapter = currentVocab.chapters[currentChapter];
            let maxQuestions = 50; // 기본값
            
            if (chapter) {
                if (chapter.type === 'midterm' || chapter.type === 'final') {
                    maxQuestions = 100; // 중간고사, 기말고사
                } else if (chapter.type === 'comprehensive') {
                    maxQuestions = 200; // 종합고사
                } else if (chapter.type === 'allwords') {
                    maxQuestions = 300; // 모든단어고사
                }
            }
            
            // ID 배열로 단어 조회
            const words = [];
            if (Array.isArray(chapterData) && chapterData.length > 0 && typeof chapterData[0] === 'string') {
                // ID 배열인 경우
                chapterData.forEach(id => {
                    const word = currentVocab.words.find(w => w.id === id);
                    if (word) words.push(word);
                });
            } else {
        // 기본적으로 단어 ID 배열이라고 가정
        console.warn('Unexpected chapter data format, assuming word IDs');
        return [];
    }
            
            // 단어를 우선순위별로 분류
            const neverCorrect = [];      // 한번도 맞추지 않은 단어
            const notMastered = [];       // 마스터 미완료 (correctCount < 3)
            const recentlyWrong = [];     // 최근 틀린 단어
            const mastered = [];          // 마스터 완료 단어
            
            for (const word of words) {
                if (word.totalAttempts === 0 || word.correctCount === 0) {
                    neverCorrect.push(word);
                } else if (word.correctCount < 3 || word.weakness > 0) {
                    notMastered.push(word);
                } else if (!word.lastCorrect) {
                    recentlyWrong.push(word);
                } else {
                    mastered.push(word);
                }
            }
            
            // 각 그룹 내에서 셔플
            shuffleArray(neverCorrect);
            shuffleArray(notMastered);
            shuffleArray(recentlyWrong);
            shuffleArray(mastered);
            
            // 우선순위에 따라 문제 구성
            let questions = [];
            
            // 1. 미마스터 단어들 먼저 추가
            questions = questions.concat(neverCorrect);
            questions = questions.concat(notMastered);
            questions = questions.concat(recentlyWrong);
            
            // 2. 50개가 안 되면 마스터 단어로 채움
            if (questions.length < maxQuestions) {
                const needed = maxQuestions - questions.length;
                questions = questions.concat(mastered.slice(0, needed));
            }
            
            // 3. 50개 초과면 자르기
            if (questions.length > maxQuestions) {
                questions = questions.slice(0, maxQuestions);
            }
            
            // 4. 최종 셔플 (문제 순서 랜덤화)
            shuffleArray(questions);
            
            console.log(`문제 구성: 총 ${questions.length}개 (미학습: ${neverCorrect.length}, 미마스터: ${notMastered.length}, 최근틀림: ${recentlyWrong.length}, 마스터: ${Math.min(mastered.length, questions.length - neverCorrect.length - notMastered.length - recentlyWrong.length)})`);
            
            return questions;
        }
        
        // Fisher-Yates 셔플 알고리즘
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // 테스트 일시정지
        function toggleTestPause() {
            isTestPaused = !isTestPaused;
            
            if (isTestPaused) {
                if (testTimer) {
                    clearTimeout(testTimer);
                    testTimer = null;
                }
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                speechSynthesis.cancel();
                showFeedback('테스트가 일시정지되었습니다', 'warning');
            } else {
                showFeedback('테스트를 재개합니다', 'success');
                startTestTimer();
            }
        }

        // 테스트 통계 업데이트
        function updateTestStats() {
            document.getElementById('testProgress').textContent = 
                `${currentTestIndex + 1}/${testQuestions.length}`;
            
            const correctCount = testAnswers.filter(a => a.correct).length;
            const accuracy = testAnswers.length > 0 ? 
                Math.round((correctCount / testAnswers.length) * 100) : 0;
            document.getElementById('currentAccuracy').textContent = accuracy + '%';
        }

        // 테스트 문제 표시
        function showCurrentTestQuestion() {
            if (isTestPaused || currentTestIndex >= testQuestions.length) return;
            
            const question = testQuestions[currentTestIndex];
            const allWords = currentVocab.words;
            
            // 카드 초기화
            document.getElementById('questionCard').className = 'question-card';
            
            // 문제 표시
            document.getElementById('questionWord').textContent = question.word;
            document.getElementById('questionExample').textContent = question.example;
            document.getElementById('questionExample').style.display = 'none';
            document.getElementById('questionExampleMeaning').textContent = question.exampleMeaning || '';
            document.getElementById('questionExampleMeaning').style.display = 'none';
            
            // 예문 초기화 (show 클래스 제거)
            document.getElementById('questionExample').classList.remove('show');
            document.getElementById('questionExampleMeaning').classList.remove('show');

            // 진행률 표시
            updateTestStats();
            
            // 선택지 생성
            const options = generateOptions(question, allWords);
            displayOptions(options, question.meaning);
            
            // 타이머 즉시 시작 (TTS와 관계없이)
            if (!isTestPaused) {
                startTestTimer();
            }
            
            // TTS는 비동기로 실행 (기다리지 않음)
            if (appData.globalSettings.testWordTTS && selectedVoice) {
                // waitingForTTS 제거 - 더 이상 기다리지 않음
                speakTextAsync(question.word);
            }
            
            saveProgress();
        }
        
        // TTS 비동기 재생 (콜백 없이)
        function speakTextAsync(text) {
            if (!selectedVoice || !text) return;
            
            try {
                // 기존 음성 중단
                speechSynthesis.cancel();
                isSpeaking = false;
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.voice = selectedVoice;
                utterance.rate = 0.9;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                
                currentUtterance = utterance;
                
                utterance.onstart = () => {
                    isSpeaking = true;
                };
                
                utterance.onend = () => {
                    isSpeaking = false;
                    currentUtterance = null;
                };
                
                utterance.onerror = (e) => {
                    console.warn('TTS 오류:', e);
                    isSpeaking = false;
                    currentUtterance = null;
                };
                
                speechSynthesis.speak(utterance);
            } catch (error) {
                console.error('TTS 재생 실패:', error);
                isSpeaking = false;
            }
        }

        // 선택지 생성 - 무한루프 방지 개선
        function generateOptions(correctAnswer, allWords) {
            const options = [correctAnswer.meaning];
            
            // 전체 단어가 많을 때 샘플링으로 메모리 절약
            let candidateWords;
            if (allWords.length > 100) {
                // 100개 이상이면 랜덤하게 50개만 샘플링
                const shuffled = [];
                const sampleSize = Math.min(50, allWords.length);
                const usedIndices = new Set();
                
                while (shuffled.length < sampleSize) {
                    const idx = Math.floor(Math.random() * allWords.length);
                    if (!usedIndices.has(idx) && allWords[idx].meaning !== correctAnswer.meaning) {
                        usedIndices.add(idx);
                        shuffled.push(allWords[idx]);
                    }
                }
                candidateWords = shuffled;
            } else {
                candidateWords = allWords.filter(w => w.meaning !== correctAnswer.meaning);
            }
            
            // 최대 6개의 선택지
            const maxOptions = Math.min(6, candidateWords.length + 1);
            let attempts = 0;
            const maxAttempts = candidateWords.length * 2; // 무한루프 방지
            
            while (options.length < maxOptions && candidateWords.length > 0 && attempts < maxAttempts) {
                attempts++;
                const randomIndex = Math.floor(Math.random() * candidateWords.length);
                const randomWord = candidateWords.splice(randomIndex, 1)[0];
                
                if (!options.includes(randomWord.meaning)) {
                    options.push(randomWord.meaning);
                }
                
                // 더 이상 후보가 없으면 종료
                if (candidateWords.length === 0) {
                    break;
                }
            }
            
            // 최소 2개의 선택지는 보장
            if (options.length < 2) {
                console.warn('선택지가 부족합니다. 최소 2개를 보장하지 못했습니다.');
                if (options.length === 1) {
                    options.push('기타');
                }
            }
            
            return options.sort(() => Math.random() - 0.5);
        }

        // 선택지 표시
        function displayOptions(options, correctAnswer) {
            const optionsGrid = document.getElementById('optionsGrid');
            optionsGrid.innerHTML = '';
            
            options.forEach(option => {
                const button = document.createElement('button');
                button.className = 'option-btn';
                button.textContent = option;
                button.onclick = () => selectOption(button, option, correctAnswer);
                optionsGrid.appendChild(button);
            });
        }

        // 선택지 선택
        function selectOption(button, selected, correct) {
            if (!isTestMode || isTestPaused) return;
            
            // 현재 재생 중인 음성 즉시 중단
            speechSynthesis.cancel();
            isSpeaking = false;
            
            // 타이머 정리
            if (testTimer) {
                clearTimeout(testTimer);
                testTimer = null;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            const isCorrect = selected === correct;
            const currentWord = testQuestions[currentTestIndex];
            
            // 모든 버튼 비활성화
            document.querySelectorAll('.option-btn').forEach(btn => {
                btn.style.pointerEvents = 'none';
                if (btn.textContent === correct) {
                    btn.classList.add('correct');
                    // 정답 버튼에 파티클 효과 추가
                    createParticles(btn);
                } else if (btn === button && !isCorrect) {
                    btn.classList.add('incorrect');
                }
            });
            
            // 카드 배경색 변경
            const questionCard = document.getElementById('questionCard');
            if (isCorrect) {
                questionCard.classList.add('correct');
            } else {
                questionCard.classList.add('incorrect');
            }
            
            // 예문 표시
            const exampleElement = document.getElementById('questionExample');
            const exampleMeaningElement = document.getElementById('questionExampleMeaning');
            
            if (exampleElement) {
                exampleElement.style.display = 'block';
                setTimeout(() => {
                    exampleElement.classList.add('show');
                }, 10);
            }
            
            if (currentWord.exampleMeaning && exampleMeaningElement) {
                exampleMeaningElement.style.display = 'block';
                setTimeout(() => {
                    exampleMeaningElement.classList.add('show');
                }, 10);
            }
            
            // 답안 기록
            testAnswers.push({
                word: currentWord,
                correct: isCorrect,
                selected: selected
            });
            
            // 단어 통계 업데이트
            updateWordStats(currentWord, isCorrect);
            
            // 테스트 통계 즉시 업데이트
            updateTestStats();
            
            // 피드백 (시각적 효과만)
            if (isCorrect) {
                createSuccessSparkles();
                vibrate([100, 50, 100]);
            } else {
                document.getElementById('questionCard').classList.add('shake');
                setTimeout(() => {
                    document.getElementById('questionCard').classList.remove('shake');
                }, 500);
                vibrate([200]);
            }
            
            // 답 선택 후 예문 읽기 (비동기)
            if (appData.globalSettings.testAnswerTTS && selectedVoice && currentWord.example) {
                speakTextAsync(currentWord.example);
            }
            
            // 다음 문제로 이동 (음성과 관계없이)
            setTimeout(() => {
                if (isTestMode && !isTestPaused) {
                    nextTestQuestion();
                }
            }, isCorrect ? 1500 : 3000);
        }

        // 파티클 효과 생성
        function createParticles(element) {
            const rect = element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // 모든 파티클을 저장할 배열
            const particles = [];
            
            // 파티클 50개로 줄임
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                const angle = (i / 50) * Math.PI * 2;
                const distance = 50 + Math.random() * 300;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;
                
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                particle.style.setProperty('--tx', tx + 'px');
                particle.style.setProperty('--ty', ty + 'px');
                
                // 별빛 색상 (흰색, 연노랑, 연파랑 계열)
                const colors = ['#ffffff', '#fffacd', '#f0f8ff', '#fafad2', '#e6e6fa', '#fff8dc'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                particle.style.background = color;
                
                // 별빛처럼 빛나는 효과 추가
                particle.style.boxShadow = `
                    0 0 ${4 + Math.random() * 4}px ${color},
                    0 0 ${8 + Math.random() * 8}px ${color},
                    0 0 ${12 + Math.random() * 12}px ${color},
                    0 0 ${16 + Math.random() * 16}px rgba(255, 255, 255, 0.8)
                `;
                
                // 크기를 더 작게 (별처럼)
                const size = 2 + Math.random() * 4;
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                
                // 투명도 랜덤
                particle.style.opacity = 0.6 + Math.random() * 0.4;
                
                // 배열에 저장
                particles.push(particle);
            }
            
            // 모든 파티클을 동시에 DOM에 추가하고 애니메이션 시작
            particles.forEach((particle) => {
                document.body.appendChild(particle);
                cleanupList.push(particle);
                
                // cleanupList 크기 제한 (최대 100개)
                if (cleanupList.length > 100) {
                    const oldElement = cleanupList.shift();
                    if (oldElement && oldElement.parentNode) {
                        oldElement.parentNode.removeChild(oldElement);
                    }
                }
                
                // 애니메이션 시작
                requestAnimationFrame(() => {
                    particle.style.animation = 'particleAnimation 1s ease-out forwards';
                });
                
                // 1초 후 제거
                setTimeout(() => {
                    if (particle.parentNode) {
                        document.body.removeChild(particle);
                    }
                    const index = cleanupList.indexOf(particle);
                    if (index > -1) {
                        cleanupList.splice(index, 1);
                    }
                }, 1000);
            });
        }
        // 테스트 타이머 시작 - 개선된 버전
        function startTestTimer() {
            if (testTimer) {
                clearTimeout(testTimer);
                testTimer = null;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            let timeLeft = 10;
            const timerFill = document.getElementById('timerFill');
            timerFill.style.width = '100%';
            
            timerInterval = setInterval(() => {
                if (isTestPaused) return;
                
                timeLeft--;
                const percentage = (timeLeft / 10) * 100;
                timerFill.style.width = percentage + '%';
                
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                    if (isTestMode && !isTestPaused) {  // waitingForTTS 제거
                        selectDontKnow();
                    }
                }
            }, 1000);
            
            testTimer = setTimeout(() => {
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
            }, 10000);
        }

        // 모르겠어요 선택
        function selectDontKnow() {
            if (!isTestMode || isTestPaused) return;
            
            // 현재 재생 중인 음성 즉시 중단
            speechSynthesis.cancel();
            isSpeaking = false;
            
            // 타이머 정리
            if (testTimer) {
                clearTimeout(testTimer);
                testTimer = null;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            const currentWord = testQuestions[currentTestIndex];
            const correct = currentWord.meaning;
            
            // 정답 표시
            document.querySelectorAll('.option-btn').forEach(btn => {
                btn.style.pointerEvents = 'none';
                if (btn.textContent === correct) {
                    btn.classList.add('correct');
                    createParticles(btn);
                }
            });
            
            // 카드 배경색 변경
            document.getElementById('questionCard').classList.add('incorrect');
            
            // 예문 표시
            const exampleElement = document.getElementById('questionExample');
            const exampleMeaningElement = document.getElementById('questionExampleMeaning');
            
            if (exampleElement) {
                exampleElement.style.display = 'block';
                setTimeout(() => {
                    exampleElement.classList.add('show');
                }, 10);
            }
            
            if (currentWord.exampleMeaning && exampleMeaningElement) {
                exampleMeaningElement.style.display = 'block';
                setTimeout(() => {
                    exampleMeaningElement.classList.add('show');
                }, 10);
            }
            
            // 답안 기록
            testAnswers.push({
                word: currentWord,
                correct: false,
                selected: '모르겠음'
            });
            
            // 단어 통계 업데이트
            updateWordStats(currentWord, false);
            
            // 테스트 통계 즉시 업데이트
            updateTestStats();
            
            // 답 선택 후 예문 읽기 (비동기)
            if (appData.globalSettings.testAnswerTTS && selectedVoice && currentWord.example) {
                speakTextAsync(currentWord.example);
            }
            
            // 다음 문제로 이동 (음성과 관계없이)
            setTimeout(() => {
                if (isTestMode && !isTestPaused) {
                    nextTestQuestion();
                }
            }, 3000);
        }

        // 다음 테스트 문제
        function nextTestQuestion() {
            currentTestIndex++;
            
            if (currentTestIndex >= testQuestions.length) {
                finishTest();
                return;
            }
            
            showCurrentTestQuestion();
        }

        // 테스트 완료
        // 테스트 완료
        function finishTest() {
            const correctCount = testAnswers.filter(a => a.correct).length;
            const accuracy = Math.round((correctCount / testAnswers.length) * 100);
            
            // 챕터 정확도 업데이트
            currentVocab.chapters[currentChapter].accuracy = accuracy;
            currentVocab.chapters[currentChapter].completedCount++;
            
            // 별 계산
            let stars = 1;
            if (accuracy >= 70) stars = 2;
            if (accuracy >= 90) stars = 3;
            
            // 현재 별보다 높으면 업데이트
            if (stars > currentVocab.chapters[currentChapter].stars) {
                currentVocab.chapters[currentChapter].stars = stars;
            }
            
            // 100점 처리
            if (accuracy === 100) {
                currentVocab.chapters[currentChapter].perfectScore = true;
            }
            
            updateStats();
            displayChapters();
            autoSave();
            
            // 테스트 진행상황 초기화
            currentVocab.testProgress = {
                chapterIndex: -1,
                currentIndex: 0,
                answers: [],
                questions: []
            };
            
            // 새로운 별 효과 표시
            showStarEffect(accuracy);
            
            setTimeout(() => {
                exitTestMode();
                showFeedback(`테스트 완료! 정확도: ${accuracy}% (${stars}⭐)`, 'success');
                
                // 테스트 모드가 사라질 때 별도 함께 제거
                document.querySelectorAll('.flying-star, .shockwave').forEach(el => el.remove());
                
                // 약한단어 권장 확인
                checkWeakWordsRecommendation();
            }, 3000); // 별 효과를 보기 위해 3초로 증가
        }
        // 새로운 별 효과 함수
        // 새로운 별 효과 함수
        function showStarEffect(accuracy) {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            // 기존 별들 제거
            document.querySelectorAll('.flying-star, .shockwave').forEach(el => el.remove());
            
            let count = 1;
            let isRainbow = false;
            
            if (accuracy === 100) {
                count = 3;
                isRainbow = true;
            } else if (accuracy >= 90) {
                count = 3;
            } else if (accuracy >= 70) {
                count = 2;
            }
            
            let starsCreated = 0;
            
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    // 별 생성
                    const star = document.createElement('div');
                    star.className = 'flying-star';
                    
                    if (isRainbow) {
                        star.innerHTML = '<span class="rainbow-star">⭐</span>';
                    } else {
                        star.textContent = '⭐';
                    }
                    
                    // 위치 설정
                    star.style.left = centerX + 'px';
                    star.style.top = centerY + 'px';
                    
                    // 애니메이션 클래스 추가
                    if (count === 3) {
                        // 삼각형 배치
                        if (i === 0) star.classList.add('triangle-top');
                        else if (i === 1) star.classList.add('triangle-left');
                        else star.classList.add('triangle-right');
                    } else if (count === 2) {
                        // 나란히 배치
                        if (i === 0) star.classList.add('line-left');
                        else star.classList.add('line-right');
                    } else {
                        // 중앙 배치
                        star.classList.add('single-star');
                    }
                    
                    document.body.appendChild(star);
                    cleanupList.push(star);
                    
                    starsCreated++;
                    
                    // 마지막 별이 도착한 후에만 충격 효과 실행
                    if (starsCreated === count) {
                        setTimeout(() => {
                            // 모든 별에 대한 충격파 생성
                            for (let j = 0; j < count; j++) {
                                // 별의 최종 위치 계산
                                let finalX = centerX;
                                let finalY = centerY;
                                
                                if (count === 3) {
                                    if (j === 0) finalY -= 70;
                                    else if (j === 1) { finalX -= 70; finalY += 70; }
                                    else { finalX += 70; finalY += 70; }
                                } else if (count === 2) {
                                    if (j === 0) finalX -= 60;
                                    else finalX += 60;
                                }
                                
                                // 충격파
                                const shockwave = document.createElement('div');
                                shockwave.className = 'shockwave';
                                shockwave.style.left = finalX + 'px';
                                shockwave.style.top = finalY + 'px';
                                document.body.appendChild(shockwave);
                                
                                // 효과 제거
                                setTimeout(() => {
                                    shockwave.remove();
                                }, 800);
                            }
                            
                            // 화면 흔들림 효과 - 현재 보이는 question-card에 적용
                            const questionCard = document.querySelector('#questionCard');
                            if (questionCard) {
                                questionCard.style.animation = 'screenShake 0.5s ease-in-out';
                                setTimeout(() => {
                                    questionCard.style.animation = '';
                                }, 500);
                            }
                        }, 1200); // 별 애니메이션이 끝나는 시간
                    }
                    
                }, i * 300);
            }
        }
        // 100점 효과
        function showPerfectScore() {
            const starElement = document.createElement('div');
            starElement.className = 'perfect-star-animation';
            starElement.innerHTML = '<span class="rainbow-star">⭐</span><span class="rainbow-star">⭐</span><span class="rainbow-star">⭐</span>';
            document.body.appendChild(starElement);
            cleanupList.push(starElement);

            // cleanupList 크기 제한 (최대 100개)
            if (cleanupList.length > 100) {
                const oldElement = cleanupList.shift();
                if (oldElement && oldElement.parentNode) {
                    oldElement.parentNode.removeChild(oldElement);
                }
            }
            
            // 폭죽 효과
            for (let i = 0; i < 100; i++) {
                // setTimeout 자체를 제거하고 바로 생성
                const particle = document.createElement('div');
                particle.className = 'particle';

                const angle = (i / 20) * Math.PI * 2;
                const distance = 50 + Math.random() * 100;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;

                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                particle.style.setProperty('--tx', tx + 'px');
                particle.style.setProperty('--ty', ty + 'px');

                // 밝은 색상
                const colors = ['#ffd700', '#ff69b4', '#87ceeb', '#98fb98', '#ffa500', '#ff6347', '#40e0d0', '#ee82ee'];
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];

                document.body.appendChild(particle);
                cleanupList.push(particle);

                // cleanupList 크기 제한
                if (cleanupList.length > 100) {
                    const oldElement = cleanupList.shift();
                    if (oldElement && oldElement.parentNode) {
                        oldElement.parentNode.removeChild(oldElement);
                    }
                }

                // 1초 후 제거
                setTimeout(() => {
                    if (particle.parentNode) {
                        document.body.removeChild(particle);
                    }
                    const index = cleanupList.indexOf(particle);
                    if (index > -1) {
                        cleanupList.splice(index, 1);
                    }
                }, 1000);
            }
        }    
        // 별 애니메이션
        function showStarAnimation(starCount) {
            const starElement = document.createElement('div');
            starElement.className = 'star-animation';
            starElement.textContent = '⭐'.repeat(starCount);
            document.body.appendChild(starElement);
            cleanupList.push(starElement);

            // cleanupList 크기 제한 (최대 100개)
            if (cleanupList.length > 100) {
                const oldElement = cleanupList.shift();
                if (oldElement && oldElement.parentNode) {
                    oldElement.parentNode.removeChild(oldElement);
                }
            }
            
            setTimeout(() => {
                if (starElement.parentNode) {
                    document.body.removeChild(starElement);
                }
                const index = cleanupList.indexOf(starElement);
                if (index > -1) {
                    cleanupList.splice(index, 1);
                }
            }, 2000);
        }

        // 테스트 모드 종료 - 진행상황 유지 (완료된 경우만 초기화)
        function exitTestMode() {
            // 타이머 정리
            if (testTimer) {
                clearTimeout(testTimer);
                testTimer = null;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            speechSynthesis.cancel();
            isTestMode = false;
            isTestPaused = false;
            
            document.getElementById('testMode').style.display = 'none';
            document.getElementById('timerFill').style.width = '100%';
            
            // 테스트가 완료되지 않은 경우 진행상황 유지
            if (currentTestIndex < testQuestions.length) {
                saveProgress();
            }
            
            // 전역 변수만 초기화 (진행상황은 유지)
            currentTestIndex = 0;
            testAnswers = [];
            testQuestions = [];
        }

        // 단어 통계 업데이트
        function updateWordStats(word, isCorrect) {
            const wordIndex = currentVocab.words.findIndex(w => w.word === word.word);
            if (wordIndex === -1) return;
            
            const wordStats = currentVocab.words[wordIndex];
            wordStats.totalAttempts++;
            currentVocab.statistics.totalAttempts++;
            
            // 최근 맞춘 단어 업데이트
            wordStats.lastCorrect = isCorrect;
            
            if (isCorrect) {
                wordStats.correctCount++;
                wordStats.consecutiveCorrect++;
                currentVocab.statistics.totalCorrect++;
                
                // 약함도 감소
                if (wordStats.weakness > 0) {
                    let reduction = 15;
                    if (wordStats.consecutiveCorrect >= 3) {
                        reduction += (wordStats.consecutiveCorrect - 2) * 5;
                    }
                    wordStats.weakness = Math.max(0, wordStats.weakness - reduction);
                }
            } else {
                wordStats.consecutiveCorrect = 0;
                
                // 약함도 증가
                if (wordStats.weakness === 0) {
                    wordStats.weakness = 45; // 첫 번째 실수
                } else {
                    // 연속 오답 페널티
                    const consecutiveWrong = wordStats.totalAttempts - wordStats.correctCount;
                    let penalty = 15;
                    if (consecutiveWrong >= 2) penalty = 30;
                    if (consecutiveWrong >= 3) penalty = 45;
                    
                    wordStats.weakness = Math.min(100, wordStats.weakness + penalty);
                }
            }
            
            updateWeakWordsList();
            updateStats();
            updateStarsForMastery();
            autoSave();
        }

        // 약한단어 권장 확인
        function checkWeakWordsRecommendation() {
            if (!currentVocab) return;
            
            const weakWords = currentVocab.words.filter(w => w.weakness >= 40);
            
            if (weakWords.length >= 10 + currentVocab.weakWordsRecommendCount) {
                document.getElementById('weakWordsRecommendModal').style.display = 'flex';
            }
        }

        // 약한단어 권장 수락
        function acceptWeakWordsRecommend() {
            document.getElementById('weakWordsRecommendModal').style.display = 'none';
            currentVocab.weakWordsRecommendCount = currentVocab.words.filter(w => w.weakness >= 40).length;
            showFocusModal();
        }

        // 약한단어 권장 거절
        function rejectWeakWordsRecommend() {
            document.getElementById('weakWordsRecommendModal').style.display = 'none';
            currentVocab.weakWordsRecommendCount = currentVocab.words.filter(w => w.weakness >= 40).length - 1;
        }
        // 별 업데이트 및 마스터 단어 체크
        function updateStarsForMastery() {
            if (!currentVocab) return;
            
            currentVocab.words.forEach(word => {
                // 마스터 조건: weakness가 0이고 correctCount가 3 이상
                if (word.weakness === 0 && word.correctCount >= 3) {
                    // 전역 마스터 단어 체크 (단어 텍스트로 체크)
                    if (!appData.globalMasteredWords) {
                        appData.globalMasteredWords = {};
                    }
                    
                    const wordText = word.word.toLowerCase();
                    
                    if (!appData.globalMasteredWords[wordText]) {
                        // 처음 마스터하는 단어
                        appData.globalMasteredWords[wordText] = {
                            firstMasteredDate: new Date().toISOString(),
                            vocabId: currentVocab.id
                        };
                        appData.userStars += 2;
                        
                        showFeedback(`🌟 새 단어 마스터! +2 별 획득!`, 'success');
                    }
                }
            });
            
            // 별 표시 업데이트
            document.getElementById('userStars').textContent = `⭐ ${appData.userStars}`;
            autoSave();
        }
        // 통계 업데이트
        function updateStats() {
            if (!currentVocab) {
                document.getElementById('totalWords').textContent = '0';
                document.getElementById('weakWords').textContent = '0';
                document.getElementById('accuracy').textContent = '0%';
                return;
            }
            
            document.getElementById('totalWords').textContent = currentVocab.words.length;
            document.getElementById('weakWords').textContent = currentVocab.words.filter(w => w.weakness >= 40).length;
            
            const accuracy = currentVocab.statistics.totalAttempts > 0 ? 
                Math.round((currentVocab.statistics.totalCorrect / currentVocab.statistics.totalAttempts) * 100) : 0;
            document.getElementById('accuracy').textContent = accuracy + '%';
            document.getElementById('userStars').textContent = `⭐ ${appData.userStars || 1000}`;
            document.getElementById('purchaseCount').textContent = (appData.purchasedVocabs || []).length;
        }

        // 약한단어 목록 업데이트
        function updateWeakWordsList() {
            if (!currentVocab) return;
            
            const weakWords = currentVocab.words
                .filter(w => w.weakness >= 40)
                .sort((a, b) => b.weakness - a.weakness)
                .slice(0, 20);
            
            const listElement = document.getElementById('weakWordsList');
            
            if (weakWords.length === 0) {
                listElement.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 40px;">약한 단어가 없습니다</div>';
                return;
            }
            
            listElement.innerHTML = '';
            
            weakWords.forEach(word => {
                const item = document.createElement('div');
                item.className = 'weak-word-item';
                
                let dangerLevel = '📝';
                if (word.weakness >= 80) dangerLevel = '🔥';
                else if (word.weakness >= 60) dangerLevel = '⚠️';
                
                const accuracy = word.totalAttempts > 0 ? 
                    Math.round((word.correctCount / word.totalAttempts) * 100) : 0;
                
                item.innerHTML = `
                    <div class="weak-word-info">
                        <div class="weak-word-title">${word.word} - ${word.meaning}</div>
                        <div class="weak-word-stats">
                            ${dangerLevel} 정답률: ${accuracy}% (${word.totalAttempts}회 시도)
                        </div>
                    </div>
                    <div class="weak-word-score">${word.weakness}</div>
                `;
                
                listElement.appendChild(item);
            });
        }

        // 집중학습 모달 표시
        function showFocusModal() {
            if (!currentVocab) return;
            
            const weakWords = currentVocab.words.filter(w => w.weakness >= 40);
            if (weakWords.length === 0) {
                showFeedback('약한 단어가 없습니다', 'error');
                return;
            }
            document.getElementById('focusModal').style.display = 'flex';
        }

        // 집중학습 모달 닫기
        function closeFocusModal() {
            document.getElementById('focusModal').style.display = 'none';
        }

        // 집중학습 시작 - 개선된 버전
        function startFocusStudy() {
            closeFocusModal();
            
            const weakWords = getWeightedWeakWords();
            if (weakWords.length === 0) {
                showFeedback('약한 단어가 없습니다', 'error');
                return;
            }
            
            console.log(`집중학습 시작: ${weakWords.length}개의 약한 단어`);
            
            // 임시 챕터 생성 - ID 유효성 확인
            const validWordIds = weakWords
                .map(w => w.id)
                .filter(id => currentVocab.words.find(word => word.id === id));
            
            if (validWordIds.length === 0) {
                console.error('집중학습: 유효한 단어 ID가 없습니다');
                showFeedback('집중학습할 단어를 찾을 수 없습니다', 'error');
                return;
            }
            
            const focusChapter = {
                id: 'focus_study',
                title: '집중학습',
                wordIds: validWordIds,
                accuracy: 0,
                stars: 0,
                completedCount: 0,
                type: 'focus',
                perfectScore: false
            };
            
            // 기존 집중 챕터 제거 후 추가
            currentVocab.chapters = currentVocab.chapters.filter(c => c.id !== 'focus_study' && c.id !== 'focus_test');
            currentVocab.chapters.push(focusChapter);
            
            // 집중학습 챕터가 제대로 생성되었는지 확인
            const addedChapter = currentVocab.chapters[currentVocab.chapters.length - 1];
            const chapterWords = getChapterWords(addedChapter);
            
            if (chapterWords.length === 0) {
                console.error('집중학습 챕터에 유효한 단어가 없습니다');
                showFeedback('집중학습할 단어를 불러올 수 없습니다', 'error');
                return;
            }
            
            console.log(`집중학습 챕터 생성 완료: ${chapterWords.length}개 단어`);
            
            currentStudyIndex = 0;
            startStudy(currentVocab.chapters.length - 1);
        }

        // 집중테스트 시작 - 개선된 버전
        function startFocusTest() {
            closeFocusModal();
            
            const weakWords = getWeightedWeakWords();
            if (weakWords.length === 0) {
                showFeedback('약한 단어가 없습니다', 'error');
                return;
            }
            
            console.log(`집중테스트 시작: ${weakWords.length}개의 약한 단어`);
            
            // 임시 챕터 생성 - ID 유효성 확인
            const validWordIds = weakWords
                .map(w => w.id)
                .filter(id => currentVocab.words.find(word => word.id === id));
            
            if (validWordIds.length === 0) {
                console.error('집중테스트: 유효한 단어 ID가 없습니다');
                showFeedback('집중테스트할 단어를 찾을 수 없습니다', 'error');
                return;
            }
            
            const focusChapter = {
                id: 'focus_test',
                title: '집중테스트',
                wordIds: validWordIds,
                accuracy: 0,
                stars: 0,
                completedCount: 0,
                type: 'focus',
                perfectScore: false
            };
            
            // 기존 집중 챕터 제거 후 추가
            currentVocab.chapters = currentVocab.chapters.filter(c => c.id !== 'focus_study' && c.id !== 'focus_test');
            currentVocab.chapters.push(focusChapter);
            
            // 집중테스트 챕터가 제대로 생성되었는지 확인
            const addedChapter = currentVocab.chapters[currentVocab.chapters.length - 1];
            const chapterWords = getChapterWords(addedChapter);
            
            if (chapterWords.length === 0) {
                console.error('집중테스트 챕터에 유효한 단어가 없습니다');
                showFeedback('집중테스트할 단어를 불러올 수 없습니다', 'error');
                return;
            }
            
            console.log(`집중테스트 챕터 생성 완료: ${chapterWords.length}개 단어`);
            
            startTest(currentVocab.chapters.length - 1);
        }

        // 가중치 적용된 약한단어 생성
        function getWeightedWeakWords() {
            const weakWords = currentVocab.words.filter(w => w.weakness >= 40);
            const weightedWords = [];
            
            weakWords.forEach(word => {
                let weight = 2; // 기본 주의 단계
                if (word.weakness >= 80) weight = 6; // 매우위험
                else if (word.weakness >= 60) weight = 4; // 위험
                
                for (let i = 0; i < weight; i++) {
                    weightedWords.push(word);
                }
            });
            
            return weightedWords.sort(() => Math.random() - 0.5);
        }

        // 데이터 저장
        function saveData() {
            const data = {
                ...appData,
                timestamp: new Date().toISOString()
            };
            
            // JSON 문자열로 변환
            const jsonString = JSON.stringify(data, null, 2);
            
            // 파일 크기 계산
            const sizeKB = (jsonString.length / 1024).toFixed(2);
            
            // JSON 파일로 다운로드
            const blob = new Blob([jsonString], {
                type: 'application/json'
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `word_master_backup_${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showFeedback(`💾 데이터가 저장되었습니다 (${sizeKB}KB)`, 'success');
        }

        // 백업 파일 불러오기
        function loadBackupData() {
            document.getElementById('backupInput').click();
        }

        // 초기화 모달 표시
        function showResetModal() {
            if (!currentVocab) {
                showFeedback('초기화할 단어장이 없습니다', 'error');
                return;
            }
            document.getElementById('resetModal').style.display = 'flex';
        }

        // 초기화 모달 닫기
        function closeResetModal() {
            document.getElementById('resetModal').style.display = 'none';
        }

        // 데이터 초기화
        function resetData() {
            if (!currentVocab) return;
            
            // 진행 중인 작업 중단
            if (isStudyMode) exitStudyMode();
            if (isTestMode) exitTestMode();
            
            const vocabId = currentVocab.id;
            const vocabName = currentVocab.name;
            
            // 현재 단어장만 초기화
            currentVocab = new Vocabulary(vocabName);
            currentVocab.id = vocabId;
            appData.vocabularies[vocabId] = currentVocab;
            
            // UI 초기화
            updateUI();
            closeResetModal();
            autoSave();
            
            // 초기화 알림
            broadcastDataChange('reset', { vocabId: vocabId });
            
            showFeedback(`🗑️ '${vocabName}' 단어장이 초기화되었습니다`, 'success');
        }

        // 피드백 표시
                // GitHub 저장소 URL (여기에 본인의 GitHub 주소를 넣으세요)
        const GITHUB_VOCAB_STORE_URL = 'https://juhyeon-maker.github.io/my-vocabulary-store';

        // 온라인 단어장 스토어 데이터
        let onlineVocabs = [];
        let currentCategory = 'all';

        // 온라인 단어장 스토어 표시
        async function showOnlineVocabStore() {
            document.getElementById('onlineVocabStoreModal').style.display = 'flex';
            
            // 로딩 표시
            document.getElementById('onlineVocabList').innerHTML = `
                <div style="text-align: center; color: #6b7280; padding: 40px;">
                    <div class="spinner"></div>
                    <p>단어장 목록을 불러오는 중...</p>
                </div>
            `;
            
            try {
                // GitHub에서 index.json 가져오기
                const response = await fetch(`${GITHUB_VOCAB_STORE_URL}/index.json`);
                if (!response.ok) throw new Error('Failed to fetch vocabulary list');
                
                const data = await response.json();
                onlineVocabs = data.categories;
                
                // 전체 카테고리 표시
                displayOnlineVocabs('all');
            } catch (error) {
                console.error('Error loading online vocabs:', error);
                document.getElementById('onlineVocabList').innerHTML = `
                    <div style="text-align: center; color: #ef4444; padding: 40px;">
                        <p>단어장 목록을 불러올 수 없습니다</p>
                        <p style="font-size: 14px; margin-top: 8px;">인터넷 연결을 확인해주세요</p>
                    </div>
                `;
            }
        }
        // 완전 초기화 모달 1 표시
        function showCompleteResetModal() {
            document.getElementById('resetStarCount').textContent = appData.userStars;
            document.getElementById('completeResetModal1').style.display = 'flex';
        }

        // 완전 초기화 모달 1 닫기
        function closeCompleteResetModal1() {
            document.getElementById('completeResetModal1').style.display = 'none';
        }

        // 완전 초기화 모달 2 표시
        function showCompleteResetModal2() {
            document.getElementById('completeResetModal1').style.display = 'none';
            document.getElementById('completeResetModal2').style.display = 'flex';
        }

        // 완전 초기화 모달 2 닫기
        function closeCompleteResetModal2() {
            document.getElementById('completeResetModal2').style.display = 'none';
        }

        // 완전 초기화 실행
        async function completeReset() {
            // 진행 중인 작업 중단
            if (isStudyMode) exitStudyMode();
            if (isTestMode) exitTestMode();
            
            // 모든 데이터 초기화
            appData = {
                vocabularies: {},
                currentVocabId: null,
                userStars: 1000,  // 기본 별로 초기화
                purchasedVocabs: [],
                globalMasteredWords: {},
                masteredWordIds: new Set(),
                globalSettings: {
                    selectedVoice: '',
                    wordTTS: true,
                    exampleTTS: false,
                    darkMode: false,
                    studySpeed: 2.8,
                    testWordTTS: true,
                    testAnswerTTS: false,
                    ttsPreload: 0,
                    visibility: {
                        word: true,
                        pronunciation: true,
                        meaning: true,
                        example: true,
                        exampleMeaning: true
                    }
                },
                version: 3
            };
            
            // 기본 단어장 생성
            const defaultVocab = new Vocabulary('기본 단어장');
            appData.vocabularies[defaultVocab.id] = defaultVocab;
            appData.currentVocabId = defaultVocab.id;
            currentVocab = defaultVocab;
            
            // 설정 UI 초기화
            restoreGlobalSettings();
            
            // UI 업데이트
            updateUI();
            
            // 저장
            await autoSave();
            
            // IndexedDB도 완전히 삭제
            if (db) {
                const transaction = db.transaction(['appData'], 'readwrite');
                const store = transaction.objectStore('appData');
                await store.clear();
            }
            
            // localStorage도 삭제
            localStorage.removeItem('wordMasterData');
            
            // 모달 닫기
            closeCompleteResetModal2();
            
            // 완료 메시지
            showFeedback('💀 모든 데이터가 완전히 초기화되었습니다', 'success');
            
            // 페이지 새로고침 (완전한 초기화를 위해)
            setTimeout(() => {
                location.reload();
            }, 2000);
        }
        // 온라인 단어장 표시
        function displayOnlineVocabs(category) {
            const listElement = document.getElementById('onlineVocabList');
            listElement.innerHTML = '';
            
            let vocabsToShow = [];
            
            if (category === 'all') {
                onlineVocabs.forEach(cat => {
                    cat.vocabularies.forEach(vocab => {
                        vocabsToShow.push({ ...vocab, categoryName: cat.name, categoryIcon: cat.icon });
                    });
                });
            } else {
                const selectedCategory = onlineVocabs.find(cat => cat.id === category);
                if (selectedCategory) {
                    selectedCategory.vocabularies.forEach(vocab => {
                        vocabsToShow.push({ ...vocab, categoryName: selectedCategory.name, categoryIcon: selectedCategory.icon });
                    });
                }
            }
            
            if (vocabsToShow.length === 0) {
                listElement.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">📭</div>
                        <div class="empty-state-text">해당 카테고리에 단어장이 없습니다</div>
                    </div>
                `;
                return;
            }
            
            vocabsToShow.forEach(vocab => {
                const item = document.createElement('div');
                item.className = 'online-vocab-item';
                
                const isDownloaded = checkIfVocabDownloaded(vocab.id);
                
                // 난이도에 따른 배지 색상
                let badgeClass = '';
                if (vocab.difficulty === '중급') badgeClass = 'intermediate';
                else if (vocab.difficulty === '고급') badgeClass = 'advanced';
                
                item.innerHTML = `
                    ${isDownloaded ? '<div class="download-status">✓ 다운로드됨</div>' : ''}
                    <div class="online-vocab-header">
                        <div class="online-vocab-info-container">
                            <div class="online-vocab-title">
                                <span>${vocab.categoryIcon || '📚'}</span>
                                <span>${vocab.name}</span>
                            </div>
                            <div class="online-vocab-meta">
                                <span class="online-vocab-badge ${badgeClass}">${vocab.difficulty}</span>
                                <span class="online-vocab-badge" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);">
                                    v${vocab.version}
                                </span>
                            </div>
                            <div class="online-vocab-description">${vocab.description}</div>
                            <div class="online-vocab-stats">
                                <div class="online-vocab-stat">
                                    <span>📝</span>
                                    <span>${vocab.wordCount}개 단어</span>
                                </div>
                                <div class="online-vocab-stat">
                                    <span>📁</span>
                                    <span>${vocab.categoryName}</span>
                                </div>
                                <div class="online-vocab-stat">
                                    <span>⭐</span>
                                    <span>${vocab.price || 50}개</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <button class="online-download-btn" onclick="downloadVocab('${vocab.url}', '${vocab.name}')" ${isDownloaded && checkIfCurrentVocabHasWords(vocab.url) ? 'disabled' : ''}>
                        ${isDownloaded ? (checkIfCurrentVocabHasWords(vocab.url) ? '✓ 이미 다운로드됨' : '🔄 무료 재다운로드') : `⭐ ${vocab.price || 50}개로 구매`}
                    </button>
                `;
                
                listElement.appendChild(item);
            });
        }

        // 온라인 단어장 검색
        function searchOnlineVocabs(searchTerm) {
            const items = document.querySelectorAll('.online-vocab-item');
            items.forEach(item => {
                const title = item.querySelector('.online-vocab-title').textContent.toLowerCase();
                const description = item.querySelector('.online-vocab-description').textContent.toLowerCase();
                
                if (title.includes(searchTerm.toLowerCase()) || description.includes(searchTerm.toLowerCase())) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        // 카테고리 필터 수정
        function filterByCategory(category) {
            currentCategory = category;
            
            // 탭 활성화 상태 변경 (애니메이션 효과 추가)
            document.querySelectorAll('.online-category-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            const activeTab = event.target.closest('.online-category-tab');
            activeTab.classList.add('active');
            
            // 클릭 효과
            activeTab.style.transform = 'scale(0.95)';
            setTimeout(() => {
                activeTab.style.transform = '';
            }, 100);
            
            displayOnlineVocabs(category);
        }

        // 다운로드 버튼 애니메이션 개선
        async function downloadVocab(url, vocabName) {
            const button = event.target;
            const originalText = button.innerHTML;
            
            button.disabled = true;
            button.innerHTML = '<span style="display: inline-block; animation: spin 1s linear infinite;">⏳</span> 다운로드 중...';
            
            try {
                // 구매 여부 확인
                const vocabId = url.split('/').pop().replace('.json', '');
                const isPurchased = checkIfVocabDownloaded(vocabId);

                // 온라인 단어장 목록에서 가격 정보 가져오기
                let vocabPrice = 50; // 기본값
                const onlineVocab = onlineVocabs.flatMap(cat => cat.vocabularies).find(v => v.url === url);
                if (onlineVocab && onlineVocab.price) {
                    vocabPrice = onlineVocab.price;
                }
                // 이미 구매한 경우 무료
                if (!isPurchased) {
                    // 처음 구매하는 경우만 별 체크
                    if (appData.userStars < vocabPrice) {
                        button.disabled = false;
                        button.innerHTML = originalText;
                        showFeedback(`⭐ 별이 부족합니다! (필요: ${vocabPrice}개, 보유: ${appData.userStars}개)`, 'error');
                        return;
                    }
                }
                const response = await fetch(`${GITHUB_VOCAB_STORE_URL}/${url}`);
                if (!response.ok) throw new Error('Failed to download vocabulary');
                
                const vocabData = await response.json();
                
                // 온라인 단어장 데이터 임시 저장
                pendingOnlineVocabData = {
                    vocabData: vocabData,
                    vocabName: vocabName,
                    vocabId: vocabId,
                    vocabPrice: vocabPrice,
                    isPurchased: isPurchased
                };
                
                // 합치기/새로만들기 선택 모달 표시
                document.getElementById('vocabMergeMessage').textContent = 
                    `'${vocabName}'을(를) 현재 단어장 '${currentVocab ? currentVocab.name : '기본 단어장'}'에 합치시겠습니까?`;
                document.getElementById('vocabMergeModal').style.display = 'flex';
                
                button.disabled = false;
                button.innerHTML = originalText;
                
            } catch (error) {
                console.error('Download error:', error);
                button.disabled = false;
                button.innerHTML = originalText;
                showFeedback('다운로드 중 오류가 발생했습니다', 'error');
            }
        }        
        async function processOnlineVocab(data) {
            const { vocabData, vocabName, vocabId, vocabPrice, isPurchased } = data;
            
            // 새 단어장인 경우 현재 단어장이 비어있으므로 바로 추가
            if (!shouldMergeVocab && currentVocab.words.length === 0) {
                // 기존 코드와 동일하게 진행
            }
            
            let addedCount = 0;
            vocabData.words.forEach(word => {
                const wordId = `${vocabData.id}_${word.word}_${Date.now()}_${Math.random()}`;
                
                if (!currentVocab.words.find(w => w.word === word.word)) {
                    currentVocab.words.push({
                        id: wordId,
                        word: word.word,
                        pronunciation: word.pronunciation || '',
                        meaning: word.meaning,
                        example: word.example || '',
                        exampleMeaning: word.exampleMeaning || '',
                        weakness: 0,
                        correctCount: 0,
                        totalAttempts: 0,
                        consecutiveCorrect: 0,
                        lastCorrect: false,
                        source: vocabName
                    });
                    addedCount++;
                }
            });
                
            if (addedCount > 0) {
                await createChapters();
                // 처음 구매시에만 별 차감 및 구매 기록
                if (!isPurchased) {
                    appData.userStars -= vocabPrice;
                    document.getElementById('userStars').textContent = `⭐ ${appData.userStars}`;
                    
                    // 구매 기록 저장
                    if (!appData.purchasedVocabs) {
                        appData.purchasedVocabs = [];
                    }
                    appData.purchasedVocabs.push(vocabId);
                    
                    // 구매 기록 UI 업데이트
                    document.getElementById('purchaseCount').textContent = appData.purchasedVocabs.length;
                    
                    showFeedback(`✨ ${vocabName} 구매 완료! (-${vocabPrice}⭐) ${addedCount}개 단어 추가`, 'success');
                } else {
                    showFeedback(`✨ ${vocabName} 재다운로드 완료! ${addedCount}개 단어 추가`, 'success');
                }
                
                // 데이터 저장
                autoSave();
                updateUI();
                
                // 성공 애니메이션
                createSuccessSparkles();
                
            } else {
                showFeedback('이미 모든 단어가 추가되어 있습니다', 'warning');
            }
        }

        function confirmVocabMerge(merge) {
            shouldMergeVocab = merge;
            document.getElementById('vocabMergeModal').style.display = 'none';
            closeOnlineVocabStore();

            if (!shouldMergeVocab) {
                // 새 단어장 생성
                const newVocabName = pendingOnlineVocabData.vocabName;
                const newVocab = new Vocabulary(newVocabName);
                appData.vocabularies[newVocab.id] = newVocab;
                appData.currentVocabId = newVocab.id;
                currentVocab = newVocab;
                
                updateUI();
                showFeedback(`📚 새 단어장 '${newVocabName}'이(가) 생성되었습니다`, 'success');
            }
            
            // 챕터 설정 모달 표시
            document.getElementById('chapterSettingModal').style.display = 'flex';
            document.getElementById('chapterSizeInput').value = currentVocab.settings.chapterSize;
        }

        // 단어장 다운로드 여부 확인
        function checkIfVocabDownloaded(vocabId) {
            // 구매 기록 확인
            return appData.purchasedVocabs && appData.purchasedVocabs.includes(vocabId);
        }
        // 현재 단어장에 해당 온라인 단어장의 단어가 있는지 확인
        function checkIfCurrentVocabHasWords(url) {
            if (!currentVocab) return false;
            const vocabId = url.split('/').pop().replace('.json', '');
            return currentVocab.words.some(word => 
                word.source && word.source.includes(vocabId)
            );
        }
        // 온라인 단어장 스토어 닫기
        function closeOnlineVocabStore() {
            document.getElementById('onlineVocabStoreModal').style.display = 'none';
        }
        function showFeedback(message, type) {
            const feedback = document.getElementById('feedback');
            feedback.textContent = message;
            feedback.className = `feedback ${type} show`;
            
            setTimeout(() => {
                feedback.classList.remove('show');
            }, type === 'warning' ? 3000 : 2000);
        }

        // 전체화면 토글
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error('전체화면 전환 실패:', err);
                });
            } else {
                document.exitFullscreen().catch(err => {
                    console.error('전체화면 종료 실패:', err);
                });
            }
        }

        // 다크모드 토글
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const toggle = document.querySelector('.dark-mode-toggle');
            toggle.textContent = document.body.classList.contains('dark-mode') ? '☀️' : '🌙';
            appData.globalSettings.darkMode = document.body.classList.contains('dark-mode');
            autoSave();
        }

        // 햅틱 피드백
        function vibrate(pattern) {
            if ('vibrate' in navigator) {
                navigator.vibrate(pattern);
            }
        }


        // 성공 시 반짝이 폭발
        function createSuccessSparkles() {
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle';
                    const container = document.querySelector('.container');
                    const rect = container.getBoundingClientRect();
                    sparkle.style.left = rect.left + rect.width / 2 + 'px';
                    sparkle.style.top = rect.top + rect.height / 2 + 'px';
                    sparkle.style.setProperty('--x', (Math.random() - 0.5) * 300 + 'px');
                    sparkle.style.setProperty('--y', (Math.random() - 0.5) * 300 + 'px');
                    sparkle.style.background = ['#667eea', '#764ba2', '#f093fb', '#10b981'][Math.floor(Math.random() * 4)];
                    sparkle.style.width = sparkle.style.height = Math.random() * 8 + 4 + 'px';
                    document.body.appendChild(sparkle);
                    cleanupList.push(sparkle);
                    
                    // cleanupList 크기 제한 (최대 100개)
                    if (cleanupList.length > 100) {
                        const oldElement = cleanupList.shift();
                        if (oldElement && oldElement.parentNode) {
                            oldElement.parentNode.removeChild(oldElement);
                        }
                    }
                    setTimeout(() => {
                        if (sparkle.parentNode) {
                            document.body.removeChild(sparkle);
                        }
                        const index = cleanupList.indexOf(sparkle);
                        if (index > -1) {
                            cleanupList.splice(index, 1);
                        }
                    }, 1000);
                }, i * 50);
            }
        }
    </script>
</body>
</html>